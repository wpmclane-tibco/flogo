[
{
	"uri": "https://tibcosoftware.github.io/flogo/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Project Flogo is an Open Source ecosystem for event-driven apps Project Flogo is an ultra-light, Go-based open source ecosystem for building event-driven apps. Event-driven, you say? Yup, the notion of triggers and actions are leveraged to process incoming events. An action, a common interface, exposes key capabilities such as application integration, stream processing, etc. \n - **App = Trigger(s) + Actions[\u0026Activities]** - **Triggers** - receive data from external sources. - are managed by a configurable threading model - have a common interface enabling anyone to build a Flogo trigger. - **Handlers** - dispatch events to actions - **Actions** - process events in a manner suitable with the implementation - have a common interface enabling opinionated event processing capabilities # Project Flogo Ecosystem All capabilities within the Flogo Ecosystem have a few things in common, they all process events (in a manner suitable for the specific purpose) and they all implement the *action* interface exposed by Flogo Core. Some of the key highlights include: üéà **Ultra-light** 20x-50x lighter than Java or Node.js  ‚ö°Ô∏è **Event-driven** Powerful event-driven programming model based on *triggers* and *actions* ‚öôÔ∏è **Common core** a single, common core enables reuse and flexibility across all eventing constructs ‚úèÔ∏è **Golang based** Written entirely in Golang for efficiency üí™ **Deployment flexibility** Deploy as ultra-lightweight serverless functions, containers or static binaries on IoT edge devices üß† **Native machine learning** Purpose built activity for TensorFlow SavedModel inferencing üòç **100% Open Source** for your dev \u0026 hacking pleasure  Integration Flows Application Integration process engine with conditional branching and a visual development environment Stream Processing a simple pipeline-based stream processing action with event joining capabilities across multiple triggers \u0026amp; aggregation over time windows Contextual Decisioning Declarative Rules for Real-time Contextual Decisions Microgateway Microgateway pattern for conditional, content-based routing, JWT validation, rate limiting, circuit breaking and other common patterns  The concept is simple, an event is just that, an event, how it‚Äôs processed is what differs. Flogo Core eases the burden by enabling a common set of functionality, such as:\n threading logging data type coercion data mapping tracing \u0026amp; monitoring hooks  While also exposing a common set of contributions via activities and triggers. For example, all available triggers can be leveraged to dispatch events to any action implementation, that is, flows for application integration, streams for stream processing, rules for contextual rule processing, etc.\nFlogo Core Flogo Core is an event-driven app framework used to develop apps for the cloud \u0026amp; IoT edge. It can also be thought of as a lightweight app kernel used by open source \u0026amp; commercial solutions.\nFlogo Core provides the following key benefits:\n‚õì Action chaining enables communication between one or more capabilities in a single, sub 10MB binary! üèó Common contribution model build activities and triggers that can be leveraged by all capabilities üî® Extensible easily extend the capabilities available by building your own action using the common interfaces\nFlogo Core Contribution Model Flogo Core exposes three principal contribution interfaces that enable developers to build common capabilities and functionality. These contribution interfaces include:\n Trigger Interface a common interface for building event-consumers that dispatch events to one or more actions. The Kafka subscriber is an example of a trigger. Activity Interface a common interface for exposing common application logic in a reusable manner. Think of this as a function, such as write to database, publish to Kafka, etc that can be used by all Flogo apps. Action Interface a common interface for processing events. Actions contain the specific capability logic, such as integration, stream processing, rule processing, etc. Actions have a great deal of flexibility in how they‚Äôre developed and how developers leverage actions within their overall applications. For example, flows and streams expose JSON-based DSLs \u0026amp; Go APIs for maximum developer flexibility.  Repos Project Flogo consists of the following sub-projects available as separate repos:\n flogo-cli: Command line tools for building Flogo apps \u0026amp; extensions flogo-core: The core Flogo library flogo-contrib: Flogo contributions/extensions project-flogo/stream: Flogo Streams Action project-flogo/rules: Contextual, deterministic rules action project-flogo/microgateway: Flogo Microgateway Action  Flogo Flows Flogo Flows provides application integration capabilities and includes the following key highlights.\nüåà Painless development Visual modeler with step-back debugging capabilities \u0026amp; elegant DSL ‚öôÔ∏è Ultra-light process engine for conditional flow control\nGetting Started We\u0026rsquo;ve made getting started with Flogo Flows as easy as possible. The current set of tooling is designed for:\n Serverless function developers Cloud-native microservices developers IoT Solutions developers Go Developers  Zero-code Developers If your background is in or you prefer to develop your apps using zero-coding environments, then read on, because we‚Äôve got something special for you.\nFlows Web UI is available via Docker Hub or Flogo.io. The Docker image contains the Flows Web UI along with all required components to begin developing, testing and building deployable artifacts right from your web browser.\nTo report any issues with the Issue tracker on this project.\nFlogo Streams Edge devices have the potential for producing millions or even billions of events at rapid intervals, often times the events on their own are meaningless, hence the need to provide basic streaming operations against the slew of events.\nA native streaming action as part of the Project Flogo Ecosystem accomplishes the following primary objectives:\n Enables apps to implement basic streaming constructs in a simple pipeline fashion Provides non-persistent state for streaming operations  Streams are persisted in memory until the end of the pipeline  Serves as a pre-process pipeline for raw data to perform basic mathematical and logical operations. Ideal for feeding ML models  Some of the key highlights include:\nüòÄ Simple pipeline construct enables a clean, easy way of dealing with streams of data ‚è≥ Stream aggregation across streams using time or event tumbling \u0026amp; sliding windows üôå Join streams from multiple event sources üå™ Filter out the noise with stream filtering capabilities\nGetting Started We‚Äôve made building powerful streaming pipelines as easy as possible. Develop your pipelines using:\n A simple, clean JSON-based DSL Golang API  See the sample below of an aggregation pipeline (for brevity, the triggers and metadata of the resource has been omitted). Also don‚Äôt forget to check out the examples in the project-flogo/stream repo.\n\u0026quot;stages\u0026quot;: [ { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/stream/activity/aggregate\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;function\u0026quot;: \u0026quot;sum\u0026quot;, \u0026quot;windowType\u0026quot;: \u0026quot;timeTumbling\u0026quot;, \u0026quot;windowSize\u0026quot;: \u0026quot;5000\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;=$.input\u0026quot; } }, { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;=$.result\u0026quot; } } ]  Flogo Rules Processing Events in real-time to determine next best action is an important function of Event driven applications. With the vast amount of events that are generated from different sources, making sense of the information in a given context can be immensely valuable.\nFlogo Rules simplifies the complexity involved with real-time contextual decisions.\nFlogo Rules supports\n Declarative Rules to define conditional logic and trigger result rules Joins/Correlations across multiple Event sources Ability to define Rule Priorities Timer Events; Configurable TTL (time to live) -1 - no expiry, 0 - event expiry set to end of run to completion cycle. Forward chaining for Inferencing  The CLI The CLI is used to build all applications that leverage the JSON-based DSL. If you‚Äôre using the Go API to build your apps, feel free to just go build your stuff without the flogo CLI.\nGetting started with the CLI couldn\u0026rsquo;t be any easier (refer to Flogo CLI repo for detail instructions and dependencies):\n Install the CLI\ngo get -u github.com/poroject-flogo/cli/...  Create \u0026amp; build your app  flogo the core CLI for creating and building your applications\n flogogen a scaffolding tool to begin building your Flogo contributions (activities, triggers \u0026amp; actions)\n  If you\u0026rsquo;re interested in building your own contribution(s), refer to the Flogo Documentation or join us on the project-flogo/Lobby Gitter Channel.\nGolang API Are you the kind of person who would rather code, but would love to leverage the capabilities of the Flogo Ecosystem? Makes total sense, we just ‚ù§Ô∏è to code also! We‚Äôve exposed a number of Go APIs for leveraging the various action types, activities and triggers. Getting started is pretty easy, just follow the steps below.\n Go get the latest flogo-lib\ngo get -u github.com/project-flogo/core/...  Optionally, if you\u0026rsquo;re using any of the Flogo contributions, don\u0026rsquo;t forget to get that repo, as well\ngo get -u github.com/project-flogo/contrib/...  Open up your favorite IDE or txt editor and start coding!\n  package main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;github.com/project-flogo/contrib/activity/log\u0026quot; \u0026quot;github.com/project-flogo/contrib/trigger/rest\u0026quot; \u0026quot;github.com/project-flogo/core/activity\u0026quot; \u0026quot;github.com/project-flogo/core/api\u0026quot; \u0026quot;github.com/project-flogo/core/data/coerce\u0026quot; \u0026quot;github.com/project-flogo/core/engine\u0026quot; ) func main() { app := myApp() e, err := api.NewEngine(app) if err != nil { fmt.Println(\u0026quot;Error:\u0026quot;, err) return } engine.RunEngine(e) } func myApp() *api.App { app := api.NewApp() trg := app.NewTrigger(\u0026amp;rest.Trigger{}, \u0026amp;rest.Settings{Port: 8080}) h, _ := trg.NewHandler(\u0026amp;rest.HandlerSettings{Method: \u0026quot;GET\u0026quot;, Path: \u0026quot;/blah/:num\u0026quot;}) h.NewAction(RunActivities) //store in map to avoid activity instance recreation logAct, _ := api.NewActivity(\u0026amp;log.Activity{}) activities = map[string]activity.Activity{\u0026quot;log\u0026quot;: logAct} return app } var activities map[string]activity.Activity func RunActivities(ctx context.Context, inputs map[string]interface{}) (map[string]interface{}, error) { trgOut := \u0026amp;rest.Output{} trgOut.FromMap(inputs) msg, _ := coerce.ToString(trgOut.PathParams) _, err := api.EvalActivity(activities[\u0026quot;log\u0026quot;], \u0026amp;log.Input{Message: msg}) if err != nil { return nil, err } response := make(map[string]interface{}) response[\u0026quot;id\u0026quot;] = \u0026quot;123\u0026quot; response[\u0026quot;amount\u0026quot;] = \u0026quot;1\u0026quot; response[\u0026quot;balance\u0026quot;] = \u0026quot;500\u0026quot; response[\u0026quot;currency\u0026quot;] = \u0026quot;USD\u0026quot; reply := \u0026amp;rest.Reply{Code: 200, Data: response} return reply.ToMap(), nil }   Before we can build the app, let\u0026rsquo;s generate the metadata for the triggers\ngo generate  Build the app\ngo build   When to use Flogo You‚Äôll look to leverage Flogo if you‚Äôre a dev \u0026amp; sick of building all the messy stuff that comes along with coding production apps. Such as connectivity to event-driven messaging platforms, datastores, SaaS apps, etc \u0026amp; want to deploy to a wide range of targets, such as\n serverless compute IoT edge devices containers  The broader Flogo ecosystem exposes an opinionated perspective on building event-driven apps. If you‚Äôre looking to process events in any of the following ways, then read on because the Project Flogo Ecosystem is for you!\n long running processes with flow-control support geared toward application integration consuming and manipulating large streams of events via a pipeline to act as a pre-processor for time-series data to serve things like machine learning models or to derive simple conclustions via data aggregation contextual, declarative rules for real-time decisioning  In short\u0026hellip;\n   Flogo is\u0026hellip; Flogo is not\u0026hellip;     an ecosystem of opinionated, event-driven capabilities a front-end web app or analytics framework   a Go lib to increase dev productivity an IoT platform    Contributing Want to contribute to Project Flogo? We\u0026rsquo;ve made it easy, all you need to do is fork the repository you intend to contribute to, make your changes and create a Pull Request! Once the pull request has been created, you\u0026rsquo;ll be prompted to sign the CLA (Contributor License Agreement) online.\nNot sure where to start? No problem, here are a few suggestions:\n flogo-contrib: This repository contains all of the standard contributions, such as activities, triggers, etc. Perhaps there is something missing? Create a new activity or trigger or fix a bug in an existing activity or trigger. Don\u0026rsquo;t forget to check all of the other repositores in the project-flogo org on GitHub, as some contributions are large enough to have their own repo. Browse all of the [Project Flogo repositories] and look for issues tagged kind/help-wanted or good first issue  If you have any questions, feel free to post an issue and tag it as a question, email flogo-oss@tibco.com or chat with the team and community:\n The project-flogo/Lobby Gitter channel should be used for general discussions, start here for all things Flogo! The project-flogo/developers Gitter channel should be used for developer/contributor focused conversations.  For additional details, refer to the Contribution Guidelines.\nLicense Project Flogo is licensed under a BSD-style license. Refer to LICENSE for license text.\nUsage Guidelines We‚Äôre excited that you‚Äôre using Project Flogo to power your project(s). Please adhere to the usage guidelines when referencing the use of Project Flogo within your project(s) and don\u0026rsquo;t forget to let others know you\u0026rsquo;re using Project Flogo by proudly displaying one of the following badges or the Flynn logo, found in the branding folder of this project.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": " Getting started Getting started with Project Flogo!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/getting-started/quickstart/",
	"title": "Quickstart",
	"tags": [],
	"description": "",
	"content": "We think it is awesome that you want to get started with Project Flogo! To get started you don\u0026rsquo;t even need to install anything other than Docker!\n  Timers are great to schedule stuff, and a great way to learn new technology! Use this lab to get familiar with some of the concepts of Flogo!      Hello World! This lab will walk you through building your first API with Project Flogo     After you\u0026rsquo;re done with these samples, why not check out the other labs we have for you!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/getting-started/getting-started-webui/",
	"title": "Flogo Web UI",
	"tags": [],
	"description": "",
	"content": " Getting Started For an overview of how to get started, check out the Quickstart guide\nFetching and starting the Web UI To get started with the latest version of the Flogo Web UI, you have two options:\n Pull the source from the flogo-web repository on GitHub (follow the instructions in the README to build and run the UI). Fetch the latest Docker image by executing the following command in your terminal window:  docker run -it -p 3303:3303 flogo/flogo-docker:latest eula-accept\nLaunching the Web UI To launch Flogo WebUI simply open your favorite web browser, and navigate to http://localhost:3303 (if you\u0026rsquo;re using the Docker Hub version, otherwise use whatever port you specified when building and starting via source). You\u0026rsquo;ll see our mascot Flynn there to greet you!\nRestarting the Web UI docker container After the Docker container has been shutdown, you may wish to simply restart the same container instance, rather than creating a new instance via the docker run command. You can easily do this by issuing the docker start command and reference the previously running container id. You can find the container name and id by using the command docker ps -a and searching for the container with the image flogo/flogo-docker. Use the ID (or name) associated with the image to issue the docker start command. For example:\ndocker start b24e4b9f3fa5\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/getting-started/getting-started-cli/",
	"title": "Flogo CLI",
	"tags": [],
	"description": "",
	"content": " Before you get started Before you can get started with the cli tools you need to make sure you have the Go programming language installed.\nFlogo makes use of Go Modules, as such, you\u0026rsquo;ll need to ensure that you have at least Go 1.11.\n Don\u0026rsquo;t forget to set your GOPATH variable and make sure that $GOPATH/bin is part of your path. (see here or here for more details)\n Installing the cli tools Now that you\u0026rsquo;ve installed the Go programming language there are a few commands you can run to install the cli and make developing with the cli tools even easier\n First you\u0026rsquo;ll need to go get flogo by running go get -u github.com/project-flogo/cli/.... This will fetch, build and install the Flogo CLI for your machine.  If you want to update the CLI tools, you can run go get -u github.com/project-flogo/cli/... to get the latest version.\n "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/",
	"title": "Labs",
	"tags": [],
	"description": "",
	"content": " Labs After getting up and running you might want to try your hand at some more advanced labs and tutorials. These labs provide you with a guides, tutorials and code samples and will help you work through building and deploying Flogo apps. The labs cover a wide range of topics like deploying to Kubernetes, using Flogo with the Serverless Framework and a bunch more! The colors of the cards have a meaning:\nFlogo CLI These labs have an emphasis on using the Flogo CLI to build apps\n Flogo CLI Project Flogo provides two different command-line interfaces and which you need depends on the task you need to execute. This tutorial covers the \u0026#39;flogo\u0026#39; command     AWS Lambda Flogo has first class support for AWS Lambda. This tutorial covers building Lambda apps using the Flogo CLI     Building activities Building new activities to extend the capabilities of Project Flogo is definitely not the most difficult thing on the planet. In fact, it\u0026#39;s rather easy to get you started!     Building triggers Triggers make it possible for Flogo to get data. How do you get started building a trigger, though? Check this tutorial to build a simple trigger.     Build using Go Cheesecakes are important! In fact, we believe perhaps the most important thing, right after Flogo. In this tutorial you\u0026#39;ll build a cheesecake service using the Go API.     Streams: Aggregate Learn how to use the JSON DSL to build streaming pipelines using the power of Flogo.     Streams: Filter Learn how to use the JSON DSL to build a simple streaming pipelines, using the power of Flogo, that filters out all zeros.     Flogo Web UI These labs have an emphasis on using the Flogo Web UI to build apps\n Timers Timers are great to schedule stuff, and a great way to learn new technology! Use this lab to get familiar with some of the concepts of Flogo!     Hello World Hello World! This lab will walk you through building your first API with Project Flogo     Bookstore Who doesn\u0026#39;t like a good book? But what if you really need to get some information about a book first? In that case you build a Flogo app that uses Google APIs to that!     Raspberry Pi Flogo runs perfectly on these small devices, and in this lab you\u0026#39;ll build a sample to read and write data to the GPIO pins of the device to control your home lights!     AWS IoT A device shadow is a digital representation in the cloud that stores and retrieves current state information for a device using AWS IoT.     Invoice Service Let\u0026#39;s build an invoiceservice! In this tutorial we\u0026#39;ll walk you through building an app with several community-driven activities and talks to other services as well.     Payment Service Who doesn\u0026#39;t want to know when payments are coming in? This service generates a payment date that can be used by the invoiceservice or standalone.     External tools These labs have an emphasis on using external tools together with Project Flogo, like Kubernetes or the Serverless Framework\n Kubernetes Kubernetes is probably the most wellknown container orchestration platform out there. In this demo you explore how to run Flogo apps on Kubernetes.     Docker Flogo apps are ultralight, so building docker images is not only really easy, because it can embed all dependencies it can also run inside of super small containers.     Cloud Foundry Cloud Foundry is an open-source platform as a service (PaaS) that provides you with a choice of clouds, developer frameworks, and application services (like Flogo!).     Serverless Framework Developers never have to worry about provisioning or maintaining servers, and only have to create the code that they need to power their next business idea!     PubNub Secure comms with PubNub: Building microservices is cool, having them talk to each other is awesome! But in today\u0026#39;s world, you can\u0026#39;t be too careful when it comes to your data.     IoT apps Flogo can run almost anywhere. Take this lab to get yourself familiar with how to develop IoT apps using the Flogo CLI.     BeagleBone Deploying apps to a BeagleBone     Intel Edison Deploying apps to an Edison     Raspberry Pi (IoT) Deploying apps to a Raspberry Pi     CI/CD for Activities A CI/CD pipeline is really important for proper a proper test and build cycle. This tutorial walks you through how to do that with Jenkins and Travis for Flogo activities.     AWS SAM SAM provides a model to build Serverless apps for AWS. It also provides an easy way of testing your apps without deploying to AWS Lambda all the time...     "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " Configuration Configurating your Flogo apps with environment variables and stuff :)\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/configuration/environment-vars/",
	"title": "Environment variables",
	"tags": [],
	"description": "",
	"content": "List of environment variables to configure the flogo engine\n   Environment name Default value Info     FLOGO_LOG_DTFORMAT \u0026ldquo;2006-01-02 15:04:05.000\u0026rdquo; Sets the log date and time format   FLOGO_LOG_LEVEL \u0026ldquo;INFO\u0026rdquo; Sets the log level   FLOGO_RUNNER_TYPE \u0026ldquo;POOLED\u0026rdquo; Sets the type of the runner   FLOGO_RUNNER_WORKERS 5 Sets the number of workers   FLOGO_RUNNER_QUEUE 50 Sets the runner queue size   FLOGO_CONFIG_PATH \u0026ldquo;flogo.json\u0026rdquo; Sets the path of the config json file   FLOGO_ENGINE_STOP_ON_ERROR true Sets whether to stop the engine on error   FLOGO_APP_PROP_RESOLVERS None The property resolver to use at runtime. Refer to the documentation for application properties   FLOGO_SCHEMA_SUPPORT     FLOGO_SCHEMA_VALIDATION None     "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": " Development All things Flogo when it comes to building your apps\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/apps/",
	"title": "Apps",
	"tags": [],
	"description": "",
	"content": " Apps Do you want to build apps and microservices? Want to better understand the concepts and constructs that make up a app? You\u0026rsquo;ve come to the right place!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/apps/app-structure/",
	"title": "App structure",
	"tags": [],
	"description": "",
	"content": " Every Flogo app has the same basic structure and files for an application.\nmyApp/ ‚îú‚îÄ‚îÄ flogo.json ‚îî‚îÄ‚îÄ src ‚îú‚îÄ‚îÄ go.mod ‚îú‚îÄ‚îÄ go.sum ‚îú‚îÄ‚îÄ imports.go ‚îú‚îÄ‚îÄ main.go  files The most important files are\n flogo.json : flogo project application configuration descriptor file imports.go : contains go imports for contributions (activities, triggers, models and functions) used by the application main.go : main file for the engine.  directories The most important directories are\n src : the place where all code is stored  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/tensorflow/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " First and foremost, Flogo supports inferencing TensorFlow models, it does not support training of models using incoming data. The training should be performed in Python and the SavedModel format exported for inferencing at runtime in Flogo.\nBefore you can begin inferencing TensorFlow models within your Flogo Flows, you‚Äôll need to consider a few requirements.\nPre-requisites The TensorFlow dynamic lib must be installed on both your development machine, as well as the target machine/device. The dynlib must be built specifically for your platform architecture, that is, Linux Arm, x86, x64, Darwin, etc. Follow the instructions documented by TensorFlow, note that the only steps that you\u0026rsquo;ll need to follow are 2 and 3: downloading the correct dynamic lib and setting your lib paths. You do not need to \u0026lsquo;go get\u0026rsquo; TensorFlow.\nTensorFlow Models As previously stated, Flogo is leveraged to inference models at runtime, not train any models. Flogo includes a native activity to inference models. The activity has been developed and tested against the output of the tf.estimator API from TensorFlow as well as manually built models saved with the tf.saved_model module.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/apps/app-configuration/",
	"title": "App Model",
	"tags": [],
	"description": "",
	"content": " Flogo Application Model The flogo.json file is the metadata describing an application. The application dictates the dependencies to be used during compile time and can also be embeded into the compiled binary.\n{ \u0026quot;name\u0026quot;: \u0026quot;SampleApp\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.1.0\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;imports\u0026quot;: [ \u0026quot;github.com/project-flogo/contrib/activity/log\u0026quot;, \u0026quot;github.com/project-flogo/contrib/trigger/rest\u0026quot;, \u0026quot;github.com/project-flogo/flow\u0026quot; ], \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;#rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple REST Trigger\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: 8080 }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/test\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:get_name\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;=$.content.name\u0026quot; }, \u0026quot;output\u0026quot;: { \u0026quot;code\u0026quot;: 200, \u0026quot;data\u0026quot;: \u0026quot;=$.greeting\u0026quot; } } } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:get_name\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;GetName\u0026quot;, \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ] }, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Logs a message\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;addDetails\u0026quot;: false } } } ] } } ] }  Root Properties  name: The application name type: The type of application. Currently the only valid value is flogo:app version: Your application version appModel: The version of the current app model. This should be: \u0026ldquo;1.1.0\u0026rdquo; description: Your application description imports: The contributions that your application will use. The imports array is used by the CLI include specific imports and versions in your application at build time. Use this to specify any additional contributions, such as, functions, that you\u0026rsquo;d like to leverage. The CLI will automatically pull any mentioned contribs at app create or during flogo imports sync command.  Triggers  id: the ID of the trigger settings: global settings for the trigger handlers the handlers for endpoints configured for the trigger  actionId: the ID of the action the handler invokes settings: the handler specific settings   "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/tensorflow/inferencing-tf/",
	"title": "Inferencing",
	"tags": [],
	"description": "",
	"content": " Before you begin with the ML Inferencing activity, refer to the Flows \u0026gt; TensorFlow \u0026gt; Getting Started documentation.\nOverview of the Inference Activity The inference activity was built to support the concept of plugable frameworks, however the only supported framework is currently TensorFlow. The activity leverages the Golang API from TensorFlow. You don\u0026rsquo;t need Python or anything other than the TensorFlow dynamic library installed on your dev \u0026amp; target machine.\nInputs model The ‚Äúmodel‚Äù input to the activity should be either of the following:\n An archive (zip) of the TensorFlow model A directory containing the exported protobuf and check point files  The activity has been tested with the exported model from the tf.estimator.Exporter.export operation as well as manually built models exported with the tf.saved_model module. After export, optionally zip the file, where the saved_model.pb file is located at the root of the archive.\nThe SavedModel format contained in the protobuf includes metadata (interpret this as an instruction manual) on how to use the model. The below inputs and outputs are which parts of the metadata to use to connect to this model.\nfeatures The data to be passed into the SavedModel are defined in ‚Äúfeatures‚Äù. This is an array of maps and should match the following format. For estimators an example of ‚Äúfeatures‚Äù is:\n[ { \u0026quot;name\u0026quot;: \u0026quot;inputs\u0026quot;, \u0026quot;data\u0026quot;:{ \u0026quot;z-axis-q75\u0026quot;: 4.140586, \u0026quot;y-axis-q75\u0026quot;: 4.140586 } } ]  And, for manually build models with multiple inputs ‚Äúfeatures‚Äù would be something like:\n[ { \u0026quot;name\u0026quot;: \u0026quot;X1\u0026quot;, \u0026quot;data\u0026quot;:[ [1,2,3], [4,5,6], [7,8,9] ] }, { \u0026quot;name\u0026quot;: \u0026quot;X2\u0026quot;, \u0026quot;data\u0026quot;:[ [0.1,0.2,0.3], [0.4,0.5,0.6], [0.7,0.8,0.9] ] } ]  framework The deep learning framework to use for inferencing. Currently the only supported value is: Tensorflow\ntag (default: ‚Äúserve‚Äù) and sigDefName (default: ‚Äúserving_default‚Äù) A TensorFlow model consists of a complex graph (network) of mathematical operations that can contain many moving parts. Another way to consider this is that a model consists of connected ‚Äúcomputers‚Äù that each have a purpose. To use the model we have to know which computer/part of the model to use. ‚Äútag‚Äù is used to identify within the model metadata which part of the model to use. Once we have selected the ‚Äúcomputer‚Äù to use we then need to know which ‚Äúports‚Äù to use. ‚ÄúsigDefName‚Äù is used within the model metadata to properly connect Flogo to the model. These Inputs into the inference activity default to the standard values used by TensorFlow.\nOutputs The output is an object and can contain multiple outputs. For example, for a classification model, the scores and classifications will be held in a map:\nmap[scores:[[0.049997408 0.010411096 0.93959147]] classes:[[Jogging Sitting Upstairs]]]  Sample application Refer to the TensorFlow samples\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/apps/application-configuration-provider/",
	"title": "Application Configuration Provider",
	"tags": [],
	"description": "",
	"content": " Unless you want to provide the application configuration (for example: flogo.json) in a different way or format you should not worry about this feature.\nWe have provided an extension mechanism for you to override the default way of providing the application configuration if needed.\nTopics  Default behavior Embedded configuration Custom configuration  Default behavior Out of the box, the default behavior will be as follows:\n Configuration will be passed to the engine in the JSON format Default path for the JSON file will be in the same directory as the application\u0026rsquo;s binary Default name for the JSON file will be \u0026ldquo;flogo.json\u0026rdquo; Default path and name can be changed by setting an environment variable \u0026ldquo;flogo.config.path\u0026rdquo; (for example:)  # Example changing default configuration path and name $ export flogo.config.path=/path/to/config/myconfig.json  Embedded configuration There is an option when building the application to compile the flogo.json and embed it into the code instead of loading it from a file.\n# Example building the application in embedded mode $ flogo build -e  Custom configuration If you need to customize the way the configuration is provided to the engine (for example: \u0026ldquo;change the format of the configuration\u0026rdquo;), you just need to do the following: * Place a file in the \u0026ldquo;main\u0026rdquo; package of your application that looks like this:\npackage main import ( \u0026quot;github.com/TIBCOSoftware/flogo-lib/app\u0026quot; ) func init () { // The name of this variable is IMPORTANT as it is initializing an existing // variable in the main.go cp = MyProvider() } // myProvider implementation of ConfigProvider type myProvider struct { } //OptimizedProvider returns an app config from a compiled json file func MyProvider() (app.ConfigProvider){ return \u0026amp;myProvider{} } // GetApp returns the app configuration func (d *myProvider) GetApp() (*app.Config, error){ app := \u0026amp;app.Config{} // Add your own code here ... return app, nil }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/apps/best-practices-app-development/",
	"title": "Best practices for app development",
	"tags": [],
	"description": "",
	"content": " There are a few best practices that we recommend when developing apps and functions using Flogo.\n.gitignore You definitely want to store your apps in a source control system and we recommend the the below template for your .gitignore for Flogo apps\n## Project Flogo .gitignore ## To restore all dependencies and prepare the project for build run ## the command `flogo imports sync` ## bin folder is constructed using flogo build /bin  using the -cv flag With the flogo cli you\u0026rsquo;re usually on the latest tagged version of the main flogo repos. If you want to pick up the latest master branch, or a specific branch, you can use the -cv flag with flogo create. This flag will pull the specified version of the project-flogo/core when the app structure is built.\n For flogo-lib you can use github.com/github.com/project-flogo/core@master  You can replace master with any branch/tag that you you want\nupdate a package to a specific version By default, the flogo cli will use the latest tagged version of any contrib. If you\u0026rsquo;d like to pick up the latest tagged release, master or a specific tagged release use the flogo update command:\nflogo update github.com/project-flogo/contrib/activity/trigger/rest@master flogo update github.com/project-flogo/contrib/activity/trigger/rest@v1.0.0 flogo update github.com/project-flogo/contrib/activity/trigger/rest@latest  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/",
	"title": "Flows",
	"tags": [],
	"description": "",
	"content": " Flows Do you want to build flows? Want to better understand the concepts and constructs that make up a flow, such as all the mapping types, valid syntax for mapping, etc? You\u0026rsquo;ve come to the right place!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/tensorflow/",
	"title": "TensorFlow",
	"tags": [],
	"description": "",
	"content": " TensorFlow Want to leverage TensorFlow within your Flogo Flows? Inference from pre-built estimators and manually constructed models to predict behaviors and outcomes to take action directly within your Flogo Flow.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/app-events/",
	"title": "App Audit Events",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/property-bag/",
	"title": "App Properties",
	"tags": [],
	"description": "",
	"content": " In Flogo, the concept of an application-level property bag is made available to flow developers that want to reuse properties across different flows, within the same application for trigger settings or as input to activities. Properties are exposed via the $property resolver and made available to the scopes defined in the mappings documentation.\nFlow configuration Properties are defined within the root of the application json, as shown below via the properties element.\n{ \u0026quot;name\u0026quot;: \u0026quot;default_app\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample flogo app\u0026quot;, \u0026quot;properties\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;my_property\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;My Property Value\u0026quot; } ]  As previously stated, properties are accessible via the $property resolver. Consider the following mappings into a log activity:\n{ \u0026quot;id\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Logs a message\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;addDetails\u0026quot;: false, \u0026quot;message\u0026quot;: \u0026quot;=$property[my_property]\u0026quot; } } }  Grouping of properties You can create an artifical grouping of related properties by using .\u0026hellip;.. naming convention. Note that property keys are still simply string literals, the engine does not do any grouping.\n{ \u0026quot;name\u0026quot;: \u0026quot;default_app\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample flogo app\u0026quot;, \u0026quot;properties\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;PURCHASE.SERVICE.DB.URL\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;postgres://10.10.10.10:5370/mydb\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;PURCHASE.SERVICE.DB.USER\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;testuser\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;INVENTORY.SERVICE.DB.URL\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;postgres://10.10.10.20:5370/mydb\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;INVENTORY.SERVICE.DB.USER\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;testuser\u0026quot; } ]  These properties can be accessed via $property[PURCHASE.SERVICE.DB.URL] or $property[INVENTORY.SERVICE.DB.URL]\nOverriding app properties at runtime You can override app properties at runtime in two ways:\nUsing JSON Define your new value for a given app prop in a json file as shown below:\nprops.json { \u0026ldquo;MyProp1\u0026rdquo;: \u0026ldquo;This is new value\u0026rdquo;, \u0026ldquo;MyProp2\u0026rdquo;: 20 }\nRun app with the environment variable FLOGO_APP_PROPS_OVERRIDE set to props.json. For example:\nFLOGO_APP_PROPS_OVERRIDE=props.json ./MyApp  Using Key/Value pair Run app with the environment variable FLOGO_APP_PROPS_OVERRIDE set to the key/value pairs. For example:\nFLOGO_APP_PROPS_OVERRIDE=\u0026quot;MyProp1=This is newvalue,MyProp2=30\u0026quot; ./MyApp  Working with external configuration management services You can plug-in your own value resolver to resolve application property value from external configuration management services, such as, Consul, Spring Cloud Config etc. Just implement the following interface and register implementation with the runtime:\n// PropertyValueResolver used to resolve value from external configuration like env, file etc type PropertyValueResolver interface { // Should return value and true if the given application property exists in the external configuration otherwise should return nil and false. LookupValue(propertyName string) (interface{}, bool) }  Sample Resolver package sampleresolver type SamplePropertyResolver struct { } func init() { app.RegisterPropertyValueResolver(\u0026quot;sampleresolver\u0026quot;, \u0026amp;SamplePropertyResolver{}) } func (resolver *SamplePropertyResolver) LookupValue(propertyName string) (interface{}, bool) { // Resolve property value return some_value, true }  Set the FLOGO_APP_PROPS_RESOLVERS env var to sampleresolver while running application. For example:\nFLOGO_APP_PROPS_RESOLVERS=sampleresolver ./\u0026lt;app_binary\u0026gt;  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/io-parameters/",
	"title": "Flow Input/Output Params",
	"tags": [],
	"description": "",
	"content": " For Flogo a Flow is more inline with the concept of a function, that is, a Flow has both input and output parameters. The concept of decoupling a trigger from a flow is a key part of supporting multiple triggers and re-use/sharing of a flow. A Flow can now operate against the data that it has defined within its declartion, in otherwords, just like a function, the scope of data that a Flow can operate against must reside within either the Flow context (or as an environment variable).\nSetting Flow Input and Output Params When building a Flow, you must first define the input and output params, that is, what are the input parameters that a flow can operate against and what parameters will be returned once the Flow has finished executing. To do this, we have options, either use the WebUI or construct the JSON manually.\nFrom the WebUI, open your new Flow, and click the \u0026ldquo;Flow Params\u0026rdquo; box, you\u0026rsquo;ll be presented with the Flow input/output editor.\nYou will be presented with a dialog containing two tabs, Input and Output. Use this dialog to define your input and output parameters.\nIf you intend to perform complex object mapping choose the type \u0026lsquo;object\u0026rsquo; for either an input or output param. This enables you to construct your own JSON, refer to the Flow Mappings section for details.\n If you\u0026rsquo;d prefer to define the Flows input and output params via the application JSON, you may do so\n{ \u0026quot;id\u0026quot;: \u0026quot;flow:my_function\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;MyFunction\u0026quot;, \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;any\u0026quot; } ] } } }  Mapping Trigger Output and Reply Because a Flow operates against its own locally scoped data (params), you will need to map the trigger data into the Flow params, as well as the flow params to the triggers reply params(s). This may sound a bit odd at first, however is required to ensure that a trigger is entierly decoupled from a flow, as previously said, enabling flows to be re-used and support multiple paths of invocation via different triggers.\nBefore we jump in, to understand the concepts used here:\n Trigger output: A trigger is an event-driven construct used to invoke a Flow. A trigger will run logic and perpare data that must be used within a Flow. Think of a REST trigger, the output of the trigger to the Flow will be things like the request data, the HTTP headers, etc. Trigger reply: After a Flow has finished executing, it may be desierable to send back data in response to the triggers request. Consider a REST trigger. If the verb was a GET, the reply would be the payload that the trigger must return to the caller.  To map the trigger data using the WebUI, add a trigger to your Flow, and click on it.\nNow select \u0026ldquo;Map flow params\u0026rdquo;.\nNow you can map the output of the trigger to Flow input params, and Flow output params can be mapped to the reply params available for the trigger.\nIf you choose to map directly within the JSON, consider the following triggers definition\n\u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;aws_lambda_trigger\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;#lambda\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;AWS Lambda Trigger\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;AWS Lambda Trigger\u0026quot;, \u0026quot;handlers\u0026quot;: [ { \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:my_function\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;=$.event.name\u0026quot; }, \u0026quot;output\u0026quot;: { \u0026quot;data\u0026quot;: \u0026quot;=$.greeting\u0026quot;, \u0026quot;status\u0026quot;: 200 } } } ] } ]  Note the input and output objects within the handler definition.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/iterators/",
	"title": "Iterator",
	"tags": [],
	"description": "",
	"content": " What is an iterator in Flogo? The iterator construct in Flogo enables the iteration of a single activity. The configuration elements are associated with that activity. In Flogo, you can iterate only over a single activity. The iterator acts much like a foreach loop in any procedural language. If you need to iterate over multiple activity calls, simply place an iterator on a subflow.\nFlow configuration Iterators are associated with an activity. The activity must have the type declared and set to iterator, as well as the iterate setting defined and the value would be either the array to iterate over or a scalar value.\n{ \u0026quot;id\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;iterator\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Logs a message\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;iterate\u0026quot;: 1 }, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;addDetails\u0026quot;: false, \u0026quot;message\u0026quot;: \u0026quot;=string.concat(\\\u0026quot;Hello \\\u0026quot;, $flow.name)\u0026quot; } } }  A few important things to note:\n A new settings element with a property named iterate set to the array that should be iterated over. It is also possible to define a static value, for example, if the value of \u0026ldquo;10\u0026rdquo; was specified, the iterator construct would invoke this activity 10 times The $iterate scope has now been introduced and can be used to access the value and key of the current iteration.  The $iterate scope has two properties:\n $current[value]: The value of the current iteration, that is, the object of the current array $current[key]: The current key (1, 2, etc)  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/flows/mapping/",
	"title": "Mappings",
	"tags": [],
	"description": "",
	"content": " What are mappings? A mapping in Flogo can be used to assign the value of a parameter (flow input, for example) to that of an input parameters of an activity or to the value of another flow scoped variable.\nTypes of mappings Flogo infers the mapping type based on the structure of the mapping itself. The following list details the specifics around each mapping type.\n   Type Description Format     literal A literal mapping. For example, mapping the string \u0026ldquo;hello\u0026rdquo; to a string typed input. Simply enclose your string literal in double quotes: \\\u0026rdquo; \\\u0026rdquo;   expression Expression mapping. This enable using functions and expression condition in mamping The mapping string should begin with an equals character =   object Complex object. Used when a JSON-based object must be built and values assigned from other scoped properties/activity outputs. See details below.   array Array mapping. Mapping an Array of Objects. See details below    Mappings are quite straightforward, for example:\n{ \u0026quot;isbn\u0026quot;: \u0026quot;=$.event.isbn\u0026quot; }  The above mapping indicates that the value of event.isbn from a trigger input should be mapped to the action input named isbn. Consider two additional samples, below you will find a mapping to an activity from a $flow scoped property, a literal mapping, as well as an object type object mapping.\nType expression from a flow-scoped property\n{ \u0026quot;isbn\u0026quot;: \u0026quot;=$flow.isbn\u0026quot; }  Type literal:\n{ \u0026quot;isbn\u0026quot;: \u0026quot;12937\u0026quot; }  Type object:\n{ \u0026quot;bookDetails\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;Author\u0026quot;: \u0026quot;=$flow.author\u0026quot;, \u0026quot;ISBN\u0026quot;: \u0026quot;=$flow.name\u0026quot;, \u0026quot;Price\u0026quot;: \u0026quot;$20\u0026quot; } } }  The literal mappings are pretty simple to understand, as are the flow scoped expression mappings. However type object does require a bit of an explanation. The mapping object is used to define how the object should be constructed and the various fields within the object mapped. This is done for performance reasons to avoid any unnecessary parsing of property values.\nIf you assign the value of an array then that param will be treated as an array, likewise for a string, int, etc. For example, let us pretend $flow.Author is an array, then the Author object would also be an array. In otherwords, direct assignment is occurring.\nThe WebUI insulates you frome much of this understanding and will infer the correct mapping type.\nAdditional type expression:\n{ \u0026quot;data.description\u0026quot;: \u0026quot;=string.concat(\\\u0026quot;The pet category name is: \\\u0026quot;, $activity[rest_3].result.category.name)\u0026quot;, }  The above sample leverages the output of a REST Invoke activity to get a pet from the public petstore service. The mapper uses a string concat function string.concat(str1, str2, str3) and assigns the function return to the description field.\nType array:\nExample 1: iterator array $fow.store.books and assign value to books\n{ \u0026quot;books\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;@foreach($flow.store.books)\u0026quot;: { \u0026quot;author\u0026quot;: \u0026quot;=$loop.author\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;=$loop.title\u0026quot;, \u0026quot;price\u0026quot;: \u0026quot;=$loop.price\u0026quot; } } } }  The above example showing how array mapping works. the mapping node same with object mapper which is used to identity an object mapping. The example: Iterate $flow.store.books source array\u0026rsquo;s author, title and price to target array books, The final target books:\n{ \u0026quot;books\u0026quot;: [ { \u0026quot;author\u0026quot;:\u0026quot;xxxx\u0026quot;, \u0026quot;titile\u0026quot;:\u0026quot;xxxx\u0026quot;, \u0026quot;price\u0026quot;: 33.33 } ] }  Description of the mapping.\nMapping Resolvers Flogo will resolve mappings with the following reference. Note the scopes table below, which indicates what objects are accessible within what scope.\n   Scope Description     $env Used to resolve an environment variable   $property Used to resolve properties from the global application property bag   $flow Used to resolve params from within the current flow. If a flow has a single trigger and no input params defined, then the output of the trigger is made available via $flow   $activity Used to resolve activity params. Activities are referenced by id, for example, $activity[acivity_id].activity_property.   $iteration[key] \u0026amp;\u0026amp; $iteration[value] Used to resolve data scoped to a current iterator    Mapping Scopes Flogo has the concept of mapping resolvers and resolvers are contained within a specific scope, hence not all objects can be accessed from anywhere within the scope.\n   Mapper Scope     Trigger-\u0026gt;Settings env and property resolvers   Trigger-\u0026gt;Handler-\u0026gt;Settings env and property resolvers   Trigger-\u0026gt;Handler-\u0026gt;actionMapper/input Trigger ouput \u0026lt;\u0026ndash; \u0026ldquo;value\u0026rdquo; field - only property and env resolver can be used. That is, only the output of the trigger or an environment variable can be used here.   Trigger-\u0026gt;Handler-\u0026gt;actionMapper/output action scope. Properties defined as ahe output of the flow can be used.   Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper/input flow \u0026lt;\u0026ndash; \u0026ldquo;value\u0026rdquo; field - all resolvers can be used   Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper/output activity input   Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;outputMapper/input activity output   Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;outputMapper/output flow   Link Expression all resolvers can be used for link expressions.    Mapping Syntax Flogo leverages a few simple syntax paradigms when mapping. The first being, the $ character which is used when accessing/reading a property and the pre-fixed . indicates that the value is available within the current scope. For example, consider the following mapping:\n{ \u0026quot;isbn\u0026quot;: \u0026quot;=$.event.isbn\u0026quot; }  The above mapping is from the Trigger/Handler, which we know, based on the indication of the ., we can only access trigger scoped (output) variables, thus event.isbn is within the trigger scope, as indicated by the preceding ..\nWhat if you\u0026rsquo;re accessing a property out of the immediate scope? The mapping should be prefixed with the $ special character, indicating to the resolver that we\u0026rsquo;re accessing a property out of the immediate scope. For example, consider the following.\n\u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;=string.concat(\\\u0026quot;Hello \\\u0026quot;, $flow.name)\u0026quot; }  This mapping is associated with Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper. We know that all resolvers can be used within the context, however none of the variables would be within the immediate scope, hence the $ should be used. For example, in the above snippet, we\u0026rsquo;re grabbing the value of the flow variable named name, hence $flow.name is used. If we wanted to grab the value of an environment variable we could use $env.VarName.\nAccessing object properties Most of the time you wont want to perform a direct assigning from one complex object to another, rather you\u0026rsquo;ll want to grab a simple type property from one complex object and perform a direct assigning to another property. This can be done accessing children using a simple dot notation. For example, consider the following mapping.\n{ \u0026quot;someObject\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;Title\u0026quot;: \u0026quot;=$activity[rest_3].result.items[0].volumeInfo.title\u0026quot;, \u0026quot;PublishedDate\u0026quot;: \u0026quot;=$activity[rest_3].result.items[0].volumeInfo.publishedDate\u0026quot;, \u0026quot;Description\u0026quot;: \u0026quot;=$activity[rest_3].result.items[0].volumeInfo.description\u0026quot; } } }  someObject is a type object and has the properties Titie, PublishedDate, Description which are being mapped from the response of an activity, this is fetched using the $activity scope. Consider one of the examples:\n$activity[rest_3].result.items[0].volumeInfo.title\nWe\u0026rsquo;re referencing the result property from the activity named rest_3. We\u0026rsquo;re then accessing an items array (the first entry of the array) to another complex object, where finally we\u0026rsquo;re at a simple string property named title.\nUsing functions and expression Most of time you want to add some custome logic to the mapping, such as concat/substring/length of a string or generate a random number base on a range and so on. any logic you want to add you can come up with an function. Refer to the functions repository for all available functions. Also note, you can install custom functions using the CLI\u0026rsquo;s flogo install command.\n{ \u0026quot;description\u0026quot;: \u0026quot;=string.concat(\\\u0026quot;The pet category name is: \\\u0026quot;, $activity[rest_3].result.category.name)\u0026quot; }  The function or expression condition can also use to link expreesion in branch, any functions that return a boolean can use in link expression.\n{ \u0026quot;from\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;log_4\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;expression\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$activity[rest_3].result.category.name == \\\u0026quot;BOOK\\\u0026quot;\u0026quot; } or  { \u0026quot;from\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;log_4\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;expression\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;string.len($flow.name) \u0026gt; 0\u0026quot; }  Hanlding arrays in mappings There are lots of use cases for array mapping, map entire array to another or iterator partial array to another with functions The array mapping value comes from a JSON format\nCase 1: iterator array $fow.store.books and assign value to books\n{ \u0026quot;books\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;@foreach($flow.store.books)\u0026quot;: { \u0026quot;author\u0026quot;: \u0026quot;=$loop.author\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;=$loop.title\u0026quot;, \u0026quot;price\u0026quot;: \u0026quot;=$loop.price\u0026quot; } } } }  Case 2: Copy original array $fow.store.books to target array books\n{ \u0026quot;books\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;@foreach($flow.store.books)\u0026quot;: { \u0026quot;=\u0026quot;: \u0026quot;$loop\u0026quot; } } } }  Case 3: Iterator array $fow.store.books and assign to primitive array titles\n{ \u0026quot;titles\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;@foreach($flow.store.books)\u0026quot;: { \u0026quot;=\u0026quot;: \u0026quot;$loop.title\u0026quot; } } } }  Case 4: Accessing parent loop data.\n{ \u0026quot;books\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;@foreach($flow.store.books, bookLoop)\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;=$loop.title\u0026quot;, \u0026quot;price\u0026quot;: \u0026quot;=$loop.price\u0026quot;, \u0026quot;author\u0026quot;: { \u0026quot;@foreach($loop.author, authorLoop)\u0026quot;: { \u0026quot;firstName\u0026quot;: \u0026quot;=$loop.firstName\u0026quot;, \u0026quot;lastName\u0026quot;: \u0026quot;=$loop[authorLoop].lastName\u0026quot;, \u0026quot;bookTitle\u0026quot;: \u0026quot;=$loop[bookLoop].title\u0026quot; } } } } } }  Case 5: Using fixed array, same as object mapper\n{ \u0026quot;store\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;store\u0026quot;: { \u0026quot;books\u0026quot;: [ { \u0026quot;author\u0026quot;: \u0026quot;=string.concat($activity[rest].result.firstName, $activity[rest].result.lastName)\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;Five little ducks\u0026quot;, \u0026quot;price\u0026quot;: 19.99 }, { \u0026quot;author\u0026quot;: \u0026quot;=string.concat($activity[rest2].result.firstName, $activity[rest2].result.lastName)\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;I love trucks\u0026quot;, \u0026quot;price\u0026quot;: 11.99 } ] } } } }   Addding @foreach(source, loopName\u0026lt;optional\u0026gt;) to indicate doing array mapping on source data Using $loop.xxx to access the current loop data xxx is the object field name Using $loop[loopName].xxx to access specific loop data  Note You can use any literal, functions, expression in array mapping.\n{ \u0026quot;books\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;@foreach($flow.store.books)\u0026quot;: { \u0026quot;author\u0026quot;: \u0026quot;=string.concat($activity[rest].result.firstName, $activity[rest].result.lastName)\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;Five little ducks\u0026quot;, \u0026quot;price\u0026quot;: 19.99 } } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/",
	"title": "Web UI",
	"tags": [],
	"description": "",
	"content": " Web UI Building flows using the Web UI is awesome! Check out this section to see all the out of the box activities we have!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/",
	"title": "Activities",
	"tags": [],
	"description": "",
	"content": " Activities An activity is the unit of work that can be leveraged within a Flow. Here is the list of the out of the box activities. If it isn\u0026rsquo;t here, check the showcase to see the amazing contributions of our community\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/functions/coerce/",
	"title": "Coerce",
	"tags": [],
	"description": "",
	"content": " Data Coerce Functions This function package enables you to coerce data from one type to another.\nValid data types in Flogo include:\n   Type Description     any Any data type.   string A string   int A standard int   int32 A 32 bit integer   int64 A 64 bit integer   float32 A 32 bit float   float64 A 64 bit float   bool A boolean (true   object A flogo object. Essentially a JOSN object   bytes A byte data type   params Parameters data type   array An array type   map A map    toType() Used to convert a value to a specified type.\nInput Args    Arg Type Description     value any The value to be coerced.   type string The data type to coerce to.    Output    Arg Type Description     returnType any The coerced value    toString() Convert the spcified value to a string.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType string The coerced string value    toInt() Convert the specified value to an int.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType int The coerced int value    toInt32() Convert the specified value to an int32.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType int32 The coerced int32 value    toInt64() Convert the specified value to a int64.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType int64 The coerced int64 value    toFloat32() Convert the specified value to a float32.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType float32 The coerced int32 value    toFloat64() Convert the specified value to a float64.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType float64 The coerced float64 value    toBool() Convert the specified value to a boolean.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType bool The coerced bool value    toBytes() Convert the specified value to bytes.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType byte The coerced byte value    toParams() Convert the specified value to params type.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType params The coerced params value    toObject() Convert the specified value to an object type.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType object The coerced object    toArray() Convert the specified value to an array.\nInput Args    Arg Type Description     value any The value to be coerced.    Output    Arg Type Description     returnType array The coerced array    "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/functions/json/",
	"title": "JSON",
	"tags": [],
	"description": "",
	"content": " JSON Functions This function package exposes common json functions.\npath() Apply a JSON path to an object.\nInput Args    Arg Type Description     path string The JSON path.   object any The object to apply the JSON path to.    Output    Arg Type Description     returnType any The result of the JSON path.    "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/functions/number/",
	"title": "Number",
	"tags": [],
	"description": "",
	"content": " Number Functions This function package exposes common number related functions.\nrandom() Generates a random number.\nInput Args    Arg Type Description     limit int The maximum number value.    Output    Arg Type Description     returnType int A non-negative pseudo-random number.    "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/actreply/",
	"title": "Reply",
	"tags": [],
	"description": "",
	"content": " Reply This activity allows you to reply to a trigger invocation and map output values. After replying to the trigger, this activity will allow the action to continue further.\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/actreply  Configuration Settings:    Name Type Description     mappings object Set of mappings to execute when the activity runs    Example The below example allows you to configure the activity to reply and set the output values to literals \u0026ldquo;name\u0026rdquo; (a string) and 2 (an integer).\n{ \u0026quot;id\u0026quot;: \u0026quot;reply\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Reply\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Reply Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/actreply\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;mappings\u0026quot;: { \u0026quot;Output1\u0026quot;:\u0026quot;name\u0026quot;, \u0026quot;Output2\u0026quot;:2 } } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/functions/string/",
	"title": "String",
	"tags": [],
	"description": "",
	"content": " String Functions This function package exposes common string related functions.\nconcat() Concatenate a set of strings.\nInput Args    Arg Type Description     str string Strings to concatinate    Output    Arg Type Description     returnType string A concatinated string.    equals() Check if two strings are equal\nInput Args    Arg Type Description     str1 string String to be compared   str2 string String to be compared    Output    Arg Type Description     returnType bool True if the strings are equal, otherwise false.    equalsIgnoreCase() Check if two strings are equal, ignoring case.\nInput Args    Arg Type Description     str1 string String to be compared   str2 string String to be compared    Output    Arg Type Description     returnType bool True if the strings are equal, otherwise false.    contains() Check if str2 is within str1.\nInput Args    Arg Type Description     str1 string Source string   str2 string String to find in str1    Output    Arg Type Description     returnType bool True if the str2 is found within str1    float() Convert str1 to a foat64.\nInput Args    Arg Type Description     str1 string Source string    Output    Arg Type Description     returnType float64 The float value of str1    integer() Convert str1 to a int.\nInput Args    Arg Type Description     str1 string Source string    Output    Arg Type Description     returnType int The int value of str1    len() Get the length of str1\nInput Args    Arg Type Description     str1 string Source string    Output    Arg Type Description     returnType int The length of str1    substring() Get a substring from str1\nInput Args    Arg Type Description     str1 string Source string   start string The starting string/char   start string The ending string/char    Output    Arg Type Description     returnType string The substring    "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/actreturn/",
	"title": "Return",
	"tags": [],
	"description": "",
	"content": " Return This activity allows you to reply to a trigger invocation and map output values. After replying to the trigger, the flow ends (this will be the last actvity in your flow).\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/actreturn  Configuration Settings:    Name Type Description     mappings object Set of mappings to execute when the activity runs    Example The below example allows you to configure the activity to reply and set the output values to literals \u0026ldquo;name\u0026rdquo; (a string) and 2 (an integer).\n{ \u0026quot;id\u0026quot;: \u0026quot;return\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Return\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/actreturn\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;mappings\u0026quot;: { \u0026quot;Output1\u0026quot;:\u0026quot;name\u0026quot;, \u0026quot;Output2\u0026quot;:2 } } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/channel/",
	"title": "Channel",
	"tags": [],
	"description": "",
	"content": " Channel This activity allows you to put a data on a named channel in the flogo engine. Channels are essentially an internal communication channel in the engine.\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/channel  Configuration Input:    Name Type Description     channel string The name of channel to use - REQUIRED   value any The data to put on the channel    "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/counter/",
	"title": "Counter",
	"tags": [],
	"description": "",
	"content": " Counter This activity allows you to use a global counter.\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/counter  Configuration Settings:    Name Type Description     counterName string The name of the counter - REQUIRED   op string The counter operation, \u0026lsquo;get\u0026rsquo; is the default operation    Output:    Name Type Description     value int The result of the counter operation    Examples Increment The below example increments a \u0026lsquo;messages\u0026rsquo; counter:\n{ \u0026quot;id\u0026quot;: \u0026quot;increment_message_count\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Increment Message Count\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/counter\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;counterName\u0026quot;: \u0026quot;messages\u0026quot;, \u0026quot;op\u0026quot;: \u0026quot;increment\u0026quot; } } }  Get The below example retrieves the last value of the \u0026lsquo;messages\u0026rsquo; counter:\n{ \u0026quot;id\u0026quot;: \u0026quot;get_message_count\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Get Message Count\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/counter\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;counterName\u0026quot;: \u0026quot;messages\u0026quot;, \u0026quot;op\u0026quot;: \u0026quot;get\u0026quot; } } }  Reset The below example resets the \u0026lsquo;messages\u0026rsquo; counter:\n{ \u0026quot;id\u0026quot;: \u0026quot;reset_message_count\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Reset Message Count\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/counter\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;counterName\u0026quot;: \u0026quot;messages\u0026quot;, \u0026quot;op\u0026quot;: \u0026quot;reset\u0026quot; } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/error/",
	"title": "Error",
	"tags": [],
	"description": "",
	"content": " Error This activity allows you to cause an explicit error in the flow (throw an error).\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/error  Configuration Input:    Name Type Description     message string The error message   data any The error data    Configuration Examples The below example throws a simple error with a message:\n{ \u0026quot;id\u0026quot;: \u0026quot;throw_error\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Throw Error\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/error\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;Unexpected Threshold Value\u0026quot; } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/log/",
	"title": "Log",
	"tags": [],
	"description": "",
	"content": " Log This activity allows you to write log messages.\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/log  Configuration Input:    Name Type Description     message string The message to log   addDetails bool Append contextual execution information to the log message    Examples The below example logs a message \u0026lsquo;test message\u0026rsquo;:\n{ \u0026quot;id\u0026quot;: \u0026quot;log_message\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log Message\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;test message\u0026quot;, \u0026quot;addDetails\u0026quot;: \u0026quot;false\u0026quot; } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/noop/",
	"title": "No-Op",
	"tags": [],
	"description": "",
	"content": " No-Op This activity is a simple No-Op that can be used for testing.\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/noop  Examples Configuration of a No-Op activity\n{ \u0026quot;id\u0026quot;: \u0026quot;noop\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;NoOp\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/noop\u0026quot; } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/appdata/",
	"title": "AppData",
	"tags": [],
	"description": "",
	"content": " AppData This activity allows you to set and get global App attributes.\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/appdata  Configuration Settings:    Name Type Description     name string The name of the shared attribute - REQUIRED   op string The operation (get or set), \u0026lsquo;get\u0026rsquo; is the default   type string The data type of the shared value, default is \u0026lsquo;any\u0026rsquo;    Input:    Name Type Description     value object The value of the shared attribute    Output:    Name Type Description     value object The value of the shared attribute    Examples Get Get the value of the \u0026lsquo;myAttr\u0026rsquo; attribute:\n{ \u0026quot;id\u0026quot;: \u0026quot;get_app_attr\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Get App Attr\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/appdata\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;attribute\u0026quot;: \u0026quot;myAttr\u0026quot;, \u0026quot;operation\u0026quot;: \u0026quot;get\u0026quot; } } }  Set Update the value of the \u0026lsquo;myAttr\u0026rsquo; attribute to bar:\n{ \u0026quot;id\u0026quot;: \u0026quot;set_app_attr\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Set App Attr\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/appdata\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;attribute\u0026quot;: \u0026quot;myAttr\u0026quot;, \u0026quot;operation\u0026quot;: \u0026quot;set\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;bar\u0026quot; } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/jsexec/",
	"title": "JSExec",
	"tags": [],
	"description": "",
	"content": " Javascript Execution Activity The jsexec activity evaluates a javascript script along with provided parameters and returns the result in the outputs.\nFlogo CLI flogo install github.com/project-flogo/contrib/activity/jsexec  Configuration Settings:    Name Type Description     script string The javascript code to evaluate    Input:    Name Type Description     parameters object Key/value pairs representing parameters to evaluate within the context of the script    Output:    Name Type Description     error bool Flag indicating if there was an error executing the script   errorMessage string The error message   result object The result object from the javascript code    Microgateway Usage A sample service definition is:\n{ \u0026quot;name\u0026quot;: \u0026quot;JSCalc\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Make calls to a JS calculator\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/jsexec\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;script\u0026quot;: \u0026quot;result.total = parameters.num * 2;\u0026quot; } }  An example step that invokes the above JSCalc service using parameters is:\n{ \u0026quot;if\u0026quot;: \u0026quot;$.PetStorePets.outputs.result.status == 'available'\u0026quot;, \u0026quot;service\u0026quot;: \u0026quot;JSCalc\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;parameters.num\u0026quot;: \u0026quot;=$.PetStorePets.outputs.result.available\u0026quot; } }  Utilizing the response values can be seen in a response handler:\n{ \u0026quot;if\u0026quot;: \u0026quot;$.PetStorePets.outputs.result.status == 'available'\u0026quot;, \u0026quot;error\u0026quot;: false, \u0026quot;output\u0026quot;: { \u0026quot;code\u0026quot;: 200, \u0026quot;data\u0026quot;: { \u0026quot;body.pet\u0026quot;: \u0026quot;=$.PetStorePets.outputs.result\u0026quot;, \u0026quot;body.inventory\u0026quot;: \u0026quot;=$.PetStoreInventory.outputs.result\u0026quot;, \u0026quot;body.availableTimesTwo\u0026quot;: \u0026quot;=$.JSCalc.outputs.result.total\u0026quot; } } }  Additional microgateway examples that utilize the jsexec activity\n api - A simple API example json - An example that using a flogo.json  Development Testing To run tests issue the following command in the root of the project:\ngo test -p 1 ./...  The -p 1 is needed to prevent tests from being run in parallel. To re-run the tests first run the following:\ngo clean -testcache  To skip the integration tests use the -short flag:\ngo test -p 1 -short ./...  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/kafka/",
	"title": "Kafka",
	"tags": [],
	"description": "",
	"content": " Kafka Activity This activity publishes messages on a topic in a Kafka cluster.\nFlogo CLI flogo install github.com/project-flogo/contrib/activity/kafka  Configuration Settings:    Name Type Description     brokerUrls string The brokers of the Kafka cluster to connect to - REQUIRED   topic string The Kafka topic on which to place the message - REQUIRED   user string If connecting to a SASL enabled port, the user id to use for authentication   password string If connecting to a SASL enabled port, the password to use for authentication   trustStore string If connecting to a TLS secured port, the directory containing the certificates representing the trust chain for the connection. This is usually just the CACert used to sign the server\u0026rsquo;s certificate    Input:    Name Type Description     message string The message to send    Output:    Name Type Description     partition int32 Documents the partition that the message was placed on   offSet int64 Documents the offset for the message    Examples The below example sends Hello From Flogo to a Kafka Broker running on localhost:\n{ \u0026quot;id\u0026quot;: \u0026quot;publish_kafka_message\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Publish Message to Kafka\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/kafka\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;brokerUrls\u0026quot; : \u0026quot;localhost:9092\u0026quot;, \u0026quot;topic\u0026quot; : \u0026quot;syslog\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot; : \u0026quot;Hello From Flogo\u0026quot; } } }  Development Testing To run tests first set up the Kafka broker using the docker-compose file given below:\nversion: '2' services: zookeeper: image: wurstmeister/zookeeper:3.4.6 expose: - \u0026quot;2181\u0026quot; kafka: image: wurstmeister/kafka:2.11-2.0.0 depends_on: - zookeeper ports: - \u0026quot;9092:9092\u0026quot; environment: KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092 KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181  Then run the following command:\ngo test  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/mapper/",
	"title": "Mapper",
	"tags": [],
	"description": "",
	"content": " Mapper This activity allows you to map values to the working attribute set of an action.\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/mapper  Configuration Settings:    Name Type Description     mappings object Set of mappings to execute    Example The below example allows you to configure the activity to map the output \u0026lsquo;value\u0026rsquo; of activity \u0026lsquo;myActivity\u0026rsquo; to FlowAttr1\n{ \u0026quot;id\u0026quot;: \u0026quot;mapper\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Mapper\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/mapper\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;mappings\u0026quot;: { \u0026quot;FlowAttr1\u0026quot;: \u0026quot;=$activity[myActivity].value\u0026quot; } ] } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/sqlquery/",
	"title": "SQL Query",
	"tags": [],
	"description": "",
	"content": " SQLQuery Database Activity This activity provides your flogo application execute database queries.\nInstallation flogo install github.com/project-flogo/activity/sqlquery  Configuration Settings:    Name Type Description     dbType string The type of database (mysql, oracle, postres, sqlite, sqlserver) - REQUIRED   driverName string The database driver name - REQUIRED   dataSourceName string The database DataSource name - REQUIRED   maxOpenConnections int Max open connections (default is unlimited)   maxIdleConnections int Max idle connections (default is 2)   query string The SQL select query - REQUIRED   disablePrepared bool Disable prepared statement usage   labeledResults bool Return results labeled by column name    Input:    Name Type Description     params map The query parameters    Output:    Name Type Description     columnNames array The names of the result columns   results array The results    Examples Query Simple query that gets all items with ID less than 10, retrieves all the columns. In order to use mysql, you have to import the driver by adding github.com/go-sql-driver/mysql to the app imports section. See github.com/go-sql-driver/mysql for more information on the driver.\n{ \u0026quot;id\u0026quot;: \u0026quot;dbquery\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;DbQuery\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/sqlquery\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;dbType\u0026quot;: \u0026quot;mysql\u0026quot;, \u0026quot;driverName\u0026quot;: \u0026quot;mysql\u0026quot;, \u0026quot;dataSourceName\u0026quot;: \u0026quot;username:password@tcp(host:port)/dbName\u0026quot;, \u0026quot;query\u0026quot;: \u0026quot;select * from test where ID \u0026lt; 10\u0026quot; } } }  Named Query Query with parameters. Parameters are referenced using \u0026lsquo;:\u0026lsquo;, e.g. :id, regardless of database\n{ \u0026quot;id\u0026quot;: \u0026quot;named_dbquery\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Named DbQuery\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/sqlquery\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;dbType\u0026quot;: \u0026quot;mysql\u0026quot;, \u0026quot;driverName\u0026quot;: \u0026quot;mysql\u0026quot;, \u0026quot;dataSourceName\u0026quot;: \u0026quot;username:password@tcp(host:port)/dbName\u0026quot;, \u0026quot;query\u0026quot;: \u0026quot;select * from test where ID \u0026lt; :id\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;params\u0026quot;: { \u0026quot;id\u0026quot;:10 } } } }  Supported Drivers  MySQL: github.com/go-sql-driver/mysql Oracle: github.com/mattn/go-oci8 Postgres: github.com/lib/pq SQLite: github.com/mattn/go-sqlite3 SQLServer: github.com/denisenkom/go-mssqldb  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/rest/",
	"title": "REST",
	"tags": [],
	"description": "",
	"content": " REST This activity allows you to invoke a REST service.\nInstallation Flogo CLI flogo install github.com/project-flogo/contrib/activity/rest  Configuration Settings:    Name Type Description     method string The HTTP method to invoke (Allowed values are GET, POST, PUT, DELETE, and PATCH) - REQUIRED   uri string The URI of the service to invoke - REQUIRED   headers params The HTTP header parameters   proxy string The address of the proxy server to be used   timeout int The request timeout in seconds   sslConfig object SSL configuration    sslConfig Object:    Property Type Description     skipVerify bool Skip SSL validation, defaults to false   useSystemCert bool Use the systems root certificate file, defaults to false   caFile string The path to PEM encoded root certificates file   certFile string The path to PEM encoded client certificate   keyFile string The path to PEM encoded client key    Input:    Name Type Description     pathParams params The path parameters (e.g., \u0026lsquo;id\u0026rsquo; in http://\u0026hellip;/pet/:id/name )   queryParams params The query parameters (e.g., \u0026lsquo;id\u0026rsquo; in http://\u0026hellip;/pet?id=someValue )   headers params The HTTP header parameters   content any The message content to send. This is only used in POST, PUT, and PATCH    Output:    Name Type Description     status int The HTTP status code   data any The HTTP response data    Examples Simple The below example retrieves a pet with number \u0026lsquo;1234\u0026rsquo; from the swagger petstore:\n{ \u0026quot;id\u0026quot;: \u0026quot;rest_activity\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;REST Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/rest\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://petstore.swagger.io/v2/pet/1234\u0026quot; } } }  Using Path Params The below example is the same as above, it retrieves a pet with number \u0026lsquo;1234\u0026rsquo; from the swagger petstore, but uses a URI parameter to configure the ID:\n{ \u0026quot;id\u0026quot;: \u0026quot;rest_activity\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;REST Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/activity/rest\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;uri\u0026quot;: \u0026quot;http://petstore.swagger.io/v2/pet/:id\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;params\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;1234\u0026quot;} } } }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/functions/",
	"title": "Functionss",
	"tags": [],
	"description": "",
	"content": " Functions Flogo Functions can be used within mapping expressions to enable a more powerful experience. For example, when mappingh data, coerce it to a specific time, concat two strings, etc.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/",
	"title": "Triggers",
	"tags": [],
	"description": "",
	"content": " Triggers Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. . Here is the list of the out of the box activities. If it isn\u0026rsquo;t here, check the showcase to see the amazing contributions of our community\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/cli/",
	"title": "CLI",
	"tags": [],
	"description": "",
	"content": " CLI Trigger This trigger provides your flogo application the ability to run as a CLI app, that is, accept input via the CLI \u0026amp; run once till completion and return the results to stdout.\nInstallation flogo install github.com/project-flogo/cli  Configuration Settings:    Name Type Description     singleCmd bool Indicates that this CLI runs only one command/handler   usage string The usage details of the CLI   long string The description of the CLI    Handler Settings:    Name Type Description     flags array List of flags   usage string The usage details of the command   short string A short description of the command   long string The description of the command    Output:    Name Type Description     args array An array of the command line arguments   flags map A map of the command line flags    Reply:    Name Type Description     data any The data that the command outputs    Flags There is simple support for defining flags for a command. You can specify either a boolean or string flag. Flags are defined using the following format: flagName||defaultValue||description\nNote: if a flag has a default value of true or false it is considered a boolean flag\nSample Configuration \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;cli\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;#cli\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;simple\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple CLI Utility\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;singleCmd\u0026quot;: true }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;commandName\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;usage\u0026quot;: \u0026quot;[flags] [args]\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;short command description\u0026quot;, \u0026quot;long\u0026quot;: \u0026quot;the long command descriptoin\u0026quot;, \u0026quot;flags\u0026quot;: [ \u0026quot;flag1||||string flag\u0026quot;, \u0026quot;flag2||false||boolan flag\u0026quot; ] }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:commandName\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;flags\u0026quot;: \u0026quot;=$.flags\u0026quot;, \u0026quot;args\u0026quot;: \u0026quot;=$.args\u0026quot; } } } ] } ]  Note: Each CLI command maps to a handler, so in order to set your command a name, you must set the name of the handler.\nExamples Triggers are configured via the triggers section of your application. The following are some example configuration of the CLI Trigger.\nSingle command An example can be found here.\nMulti command An example can be found here.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/kafka/",
	"title": "Kafka",
	"tags": [],
	"description": "",
	"content": " Kafka Trigger This trigger subscribes to a topic on Kafka cluster and listens for the messages.\nFlogo CLI flogo install github.com/project-flogo/contrib/trigger/kafka  Configuration Setting :    Name Type Description     brokerUrls string The brokers of the Kafka cluster to connect to - REQUIRED   user string If connecting to a SASL enabled port, the userid to use for authentication   password string If connecting to a SASL enabled port, the password to use for authentication   trustStore string If connecting to a TLS secured port, the directory containing the certificates representing the trust chain for the connection. This is usually just the CACert used to sign the server\u0026rsquo;s certificate    HandlerSettings:    Name Type Description     topic string The Kafka topic on which to listen for messages   partitions string The specific partitions to consume messages from   offset int64 The offset to use when starting to consume messages    Output:    Name Type Description     message string The message that was consumed    Examples { \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flogo-kafka\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/kafka\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;brokerUrls\u0026quot; : \u0026quot;localhost:9092\u0026quot;, \u0026quot;trustStore\u0026quot; : \u0026quot;\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;topic\u0026quot;: \u0026quot;syslog\u0026quot;, }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:my_flow\u0026quot; } } } ] } ] }  Development Testing To run tests first set up the kafka broker using the docker-compose file given below:\nversion: '2' services: zookeeper: image: wurstmeister/zookeeper:3.4.6 expose: - \u0026quot;2181\u0026quot; kafka: image: wurstmeister/kafka:2.11-2.0.0 depends_on: - zookeeper ports: - \u0026quot;9092:9092\u0026quot; environment: KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092 KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181  Then run the following command:\ngo test  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/channel/",
	"title": "Channel",
	"tags": [],
	"description": "",
	"content": " Channel Trigger This trigger provides your flogo application the ability to start an action via a named engine channel\nInstallation flogo install github.com/project-flogo/contrib/trigger/channel  Configuration Handler Settings:    Name Type Description     channel string The internal engine channel - REQUIRED    Output:    Name Type Description     data any The data pulled from the channel    Example Configurations Triggers are configured via the triggers.json of your application. The following are some example configuration of the Channel Trigger.\nRun Flow Configure the Trigger to handle an event received on the \u0026lsquo;test\u0026rsquo; channel\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flogo-channel\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/channel\u0026quot;, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;channel\u0026quot;: \u0026quot;test\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:testflow\u0026quot; } } } ] } ] }  Note: a channel must be defined in the app in order to use it in a trigger or activity. A channel is specified by \u0026ldquo;\u0026lt;name\u0026gt;:\u0026lt;buffer size\u0026gt;\u0026ldquo;\n\u0026quot;channels\u0026quot;: [ \u0026quot;test:5\u0026quot; ]  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/loadtester/",
	"title": "LoadTester",
	"tags": [],
	"description": "",
	"content": " LoadTester Trigger This trigger provides your flogo application the ability to run simple load test on a specified action\nImplementation based off go-wrk.\nInstallation flogo install github.com/project-flogo/contrib/trigger/loadtester  Configuration Settings:    Name Type Description     startDelay int The start delay of the test in seconds, default: 30   duration int The duration of the test in seconds, default: 60   concurrency int The level of concurrency, default: 5   data any Optional data to pass along to the action   handler string The named handler to test, defaults to the first handler    Output:    Name Type Description     data any The data from the settings to pass along    Example Configuration Test Flow Configure the Trigger to load test the \u0026lsquo;flow:testflow\u0026rsquo;\njson { \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;tester\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/loadtester\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;startDelay\u0026quot;: 15, \u0026quot;duration\u0026quot;: 120, \u0026quot;concurrency\u0026quot; : 5, \u0026quot;handler\u0026quot;: \u0026quot;test\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:testflow\u0026quot; } } } ] } ] } ``\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/rest/",
	"title": "REST",
	"tags": [],
	"description": "",
	"content": " REST Trigger This trigger provides your flogo application the ability to start an action via REST over HTTP\nInstallation flogo install github.com/project-flogo/contrib/trigger/rest  Configuration Settings:    Name Type Description     port int The port to listen on - REQUIRED   enableTLS bool Enable TLS on the server   certFile string The path to PEM encoded server certificate   keyFile string The path to PEM encoded server key    Handler Settings:    Name Type Description     method string The HTTP method (ie. GET,POST,PUT,PATCH or DELETE) - REQUIRED   path string The resource path - REQUIRED    Output:    Name Type Description     pathParams params The path parameters (e.g., \u0026lsquo;id\u0026rsquo; in http://\u0026hellip;/pet/:id/name )   queryParams params The query parameters (e.g., \u0026lsquo;id\u0026rsquo; in http://\u0026hellip;/pet?id=someValue )   headers params The HTTP header parameters   content any The content of the request    Reply:    Name Type Description     code int The http code to reply with   data any The data to reply with    Example Configurations Triggers are configured via the triggers.json of your application. The following are some example configuration of the REST Trigger.\nPOST Configure the Trigger to handle a POST on /device\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flogo-rest\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/rest\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: 8080 }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;POST\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/device\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:new_device_flow\u0026quot; } } } ] } ] }  GET Configure the Trigger to handle a GET on /device/:id\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flogo-rest\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/rest\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: 8080 }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/device/:id\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:get_device_flow\u0026quot; }, \u0026quot;input\u0026quot;:{ \u0026quot;deviceId\u0026quot;:\u0026quot;=$.pathParams.id\u0026quot; } } } ] } ] }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/timer/",
	"title": "Timer",
	"tags": [],
	"description": "",
	"content": " Timer Trigger This trigger provides your flogo application the ability to schedule an action\nInstallation flogo install github.com/project-flogo/contrib/trigger/timer  Configuration Handler Settings:    Name Type Description     startDelay string The start delay (ex. 1m, 1h, etc.), immediate if not specified   repeatInterval string The repeat interval (ex. 1m, 1h, etc.), doesn\u0026rsquo;t repeat if not specified    Example Configurations Triggers are configured via the triggers.json of your application. The following are some example configuration of the Timer Trigger.\nOnly once and immediate Configure the Trigger to run a flow immediately\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flogo-timer\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/timer\u0026quot;, \u0026quot;handlers\u0026quot;: [ { \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:myflow\u0026quot; } } } ] } ] }  Only once with a delay Configure the Trigger to run a flow once with a delay of one minute. \u0026ldquo;startDelay\u0026rdquo; settings format = \u0026ldquo;[hours]h[minutes]m[seconds]s\u0026rdquo;\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flogo-timer\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/timer\u0026quot;, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;startDelay\u0026quot;: \u0026quot;1m\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:myflow\u0026quot; } } } ] } ] }  Repeating Configure the Trigger to run a flow repeating every 10 minutes. \u0026ldquo;repeatInterval\u0026rdquo; settings format = \u0026ldquo;[hours]h[minutes]m[seconds]s\u0026rdquo;\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flogo-timer\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/timer\u0026quot;, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;repeatInterval\u0026quot;: \u0026quot;10m\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:myflow\u0026quot; } } } ] } ] }  Repeating with start delay Configure the Trigger to run a flow every minute, with a delayed start of 10 minutes and 30 seconds.\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flogo-timer\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/contrib/trigger/timer\u0026quot;, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;repeatInterval\u0026quot;: \u0026quot;1m\u0026quot;, \u0026quot;startDelay\u0026quot;: \u0026quot;10m30s\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:myflow\u0026quot; } } } ] } ] }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/flogo-cli/",
	"title": "Flogo CLI Tools",
	"tags": [],
	"description": "",
	"content": " Flogo CLI Discover the Flogo CLI tools to build applications \u0026amp; extensions.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/flogo-cli/flogo-cli/",
	"title": "flogo",
	"tags": [],
	"description": "",
	"content": " Commands  build - Build the flogo application create - Create a flogo application project help - Help about any command imports - Manage project dependency imports install - Install a flogo contribution/dependency list - List installed flogo contributions plugin - Manage CLI plugins update - Update an application contribution/dependency  Global Flags  --verbose verbose output  build This command is used to build the application.\nUsage: flogo build [flags] Flags: -e, --embed embed configuration in binary -f, --file string specify a flogo.json to build -o, --optimize optimize build --shim string use shim trigger  Note: the optimize flag removes unused trigger, acitons and activites from the built binary.\nExamples Build the current project application\n$ flogo build  Build an application directly from a flogo.json\n$ flogo build -f flogo.json  Note: this command will only generate the application binary for the specified json and can be run outside of a flogo application project\ncreate This command is used to create a flogo application project.\nUsage: flogo create [flags] [appName] Flags: --cv string specify core library version (ex. master) -f, --file string specify a flogo.json to create project from  Note: when using the \u0026ndash;cv flag to specify a version, the exact version specified might not be used the project. The application will install the version that satisfies all the dependency constraints. Typically this flag is used when trying to use the master version of the core library.\nExamples Create a base sample project with a specific name:\n$ flogo create my_app  Create a project from an existing flogo application descriptor:\n$ flogo create -f myapp.json  help This command shows help for any flogo commands.\nUsage: flogo help [command]  Examples Get help for the build command:\n$ flogo help build  imports This command helps manage project imports of contributions and dependencies.\nUsage: flogo imports [command] Available Commands: sync sync Go imports to project imports resolve resolve project imports to installed version list list project imports  install This command is used to install a flogo contribution or dependency.\nUsage: flogo install [flags] \u0026lt;contribution|dependency\u0026gt; Flags: -f, --file string specify contribution bundle -r, --replace string specify path to replacement contribution/dependency  Examples Install the basic REST trigger:\n$ flogo install github.com/project-flogo/contrib/trigger/rest  Install a contribution that you are currently developing on your computer:\n$ flogo install -r /tmp/dev/myactivity github.com/myuser/myactivity  Install a contribution that is being developed by different person on their fork:\n$ flogo install -r github.com/otherusr/myactivity@master github.com/myuser/myactivity  list This command lists installed contributions in your application\nUsage: flogo list [flags] Flags: --filter string apply list filter [used, unused] -j, --json print in json format (default true) --orphaned list orphaned refs  Note orphaned refs are ref entries that use an import alias (ex. \u0026quot;ref\u0026quot;: \u0026quot;#log\u0026quot;) which has no corresponding import.\nExamples List all installed contributions:\n$ flogo list  List all contributions directly used by the application:\n$ flogo list --filter used  Note: the results of this command are the only contributions that will be compiled into your application when using flogo build with the optimize flag\nplugin This command is used to install a plugin to the Flogo CLI.\nUsage: flogo plugin [command] Available Commands: install install CLI plugin list list installed plugins update update plugin  Examples List all installed plugins:\n$ flogo plugin list  Install the legacy support plugin:\n$ flogo plugin install github.com/project-flogo/legacybridge/cli`  Note: more information on the legacy support plugin can be found here\nInstall and use custom plugin:\n$ flogo plugin install github.com/myuser/myplugin $ flogo `your_command`  \nMore information on Flogo CLI plugins can be found here\nupdate This command updates a contribution or dependency in the project.\nUsage: flogo update [flags] \u0026lt;contribution|dependency\u0026gt;  Examples Update you log activity to master:\n$ flogo update github.com/project-flogo/contrib/activity/log@master  Update your flogo core library to latest master:\n$ flogo update github.com/project-flogo/core@master  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/flogo-cli/plugins/",
	"title": "plugins",
	"tags": [],
	"description": "",
	"content": " Plugins The Flogo CLI has support for plugins. These plugins can be used to extend the Flogo CLI command.\nCreating a CLI plugin First lets setup the go project:\n# Create a directory for your plugin project $ mkdir myplugin # Go to the directory $ cd myplugin # Initialize the Go module information $ go mod init github.com/myuser/myplugin # Edit/Create the plugin code $ vi myplugin.go  Next lets create the code for our simple plugin:\npackage myplugin import ( \u0026quot;fmt\u0026quot; \u0026quot;github.com/project-flogo/cli/common\u0026quot; // Flogo CLI support code \u0026quot;github.com/spf13/cobra\u0026quot; ) func init() { common.RegisterPlugin(myCmd) } var myCmd = \u0026amp;cobra.Command{ Use:\t\u0026quot;mycmd\u0026quot;, Short:\t\u0026quot;says hello world\u0026quot;, Long:\t\u0026quot;This plugin command says hello world\u0026quot;, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026quot;Hello World\u0026quot;) }, }  Once you save the code, we need to fix up the Go Module dependencies.\n$ go mod tidy  Now you are ready to test out your plugin. First you must host your plugin in your git repository. Then you are ready to install and run your plugin\n# Install your plugin $ flogo plugin install github.com/myuser/myplugin # Run your new plugin command $ flogo mycmd  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/deployments/",
	"title": "Cloud Deployments",
	"tags": [],
	"description": "",
	"content": " Deploy to all the clouds Flogo can be deployed to pretty much any cloud platform that exists today, whether it is a FaaS platform or a more traditional cloud platform.\n  Kubernetes is probably the most wellknown container orchestration platform out there. In this demo you explore how to run Flogo apps on Kubernetes. The demo will walk you thro      Flogo apps are ultralight, so building docker images is not only really easy, because it can embed all dependencies it can also run inside of super small containers. Check out      Cloud Foundry is an open-source platform as a service (PaaS) that provides you with a choice of clouds, developer frameworks, and application services. The most awesome thing?     After you\u0026rsquo;re done with these samples, why not check out the other labs we have for you!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/iot/",
	"title": "IoT",
	"tags": [],
	"description": "",
	"content": " The Internet of Things The Internet of Things is a magnificent place and with Flogo you can make it even better. To get started we\u0026rsquo;ve created a write-up of how to deploy your Flogo apps to some of the most common devices we could find.\n  Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps f      Deploying apps to a BeagleBone      Deploying apps to an Edison      Deploying apps to a Raspberry Pi     After you\u0026rsquo;re done with these samples, why not check out the other labs we have for you!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/faas/",
	"title": "FaaS",
	"tags": [],
	"description": "",
	"content": " Flows as Functions for Serverless Platforms Discover how you can use Project Flogo to build a Flow as Functions.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/faas/how-to/",
	"title": "Flogo and Lambda",
	"tags": [],
	"description": "",
	"content": "            \nServerless is all around us and perhaps the fastest growing market for compute. Flogo has first class support for AWS Lambda. So you can infinitely scale your ultralight functions and scale back to zero when not in use with AWS Lambda‚Äôs NoOps and seamless scaling capabilities.\nWe‚Äôll guide you through the set of steps required to build the most basic of functions for deployment to AWS Lambda. The flow you‚Äôll build will be the function you deploy.\nPrerequisites Before we get started there are a few prerequisites that we need to take into account:\n You‚Äôll need to have the Flogo CLI and at least Go 1.11 installed If you want to deploy using the AWS cli you\u0026rsquo;ll need to install that too You‚Äôll obviously need an AWS account :)  Create the flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. You can copy the below content and paste it into a file called flogo.json. The Flogo app has a Lambda trigger which can be triggered by any event supported by AWS Lambda.\n{ \u0026quot;name\u0026quot;: \u0026quot;myApp\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.1.0\u0026quot;, \u0026quot;imports\u0026quot;: [ \u0026quot;github.com/project-flogo/flow\u0026quot;, \u0026quot;github.com/project-flogo/aws-contrib/trigger/lambda\u0026quot;, \u0026quot;github.com/project-flogo/contrib/activity/actreturn\u0026quot;, \u0026quot;github.com/project-flogo/contrib/activity/log\u0026quot;, \u0026quot;github.com/project-flogo/contrib/function/string\u0026quot; ], \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;aws_lambda_trigger\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;#lambda\u0026quot;, \u0026quot;settings\u0026quot;: null, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: null, \u0026quot;actions\u0026quot;: [ { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:my_function\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;=$.event.name\u0026quot; }, \u0026quot;output\u0026quot;: { \u0026quot;data\u0026quot;: \u0026quot;=$.greeting\u0026quot;, \u0026quot;status\u0026quot;: 200 } } ] } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:my_function\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;MyFunction\u0026quot;, \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;any\u0026quot; } ] }, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Logs a message\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;addDetails\u0026quot;: false, \u0026quot;message\u0026quot;: \u0026quot;=string.concat(\\\u0026quot;Hello \\\u0026quot;, $flow.name)\u0026quot; } } }, { \u0026quot;id\u0026quot;: \u0026quot;actreturn_3\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Return\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Return Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#actreturn\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;mappings\u0026quot;: { \u0026quot;greeting\u0026quot;: { \u0026quot;mapping\u0026quot;: { \u0026quot;Hello\u0026quot;: \u0026quot;=$flow.name\u0026quot; } } } } } } ], \u0026quot;links\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;actreturn_3\u0026quot; } ] } } ] }  Create an app To create the source code simply execute\nflogo create -f flogo.json myapp  This tells the flogo cli to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nBuild The next step is to build the executable and for that we need to be in the directory myapp. To build a flogo app from the source that you can run on AWS Lambda we\u0026rsquo;ll need to execute the command\nflogo build -e -shim start_flow_as_a_function_in_lambda  . This command tells the flogo cli to build the app as an embedded application (the -e option) and with a target shim (the -shim option which uses the trigger id). The AWS Lambda trigger leverages a makefile to kick off the build process, which simply builds your Flogo application using the Lambda trigger shim and zips the binary for deployment to AWS Lambda.\nOnce this command finishes successfully the zip file (handler.zip) will be located in your app src directory (for example /path/to/app/lambda/src/lambda/handler.zip).\nDeploy There are several ways to deploy to AWS Lambda. A non-exhaustive list is:\n Uploading the code Using SAM templates Using Serverless Framework Using the AWS CLI  In this scenario we\u0026rsquo;ll look at numbers 1 and 4\nUploading the code From the Lambda console you can easily create a new function. As you do that set the runtime to Go 1.x, upload the zip file and set the handler to handler.\nUsing the AWS CLI To deploy your app using the AWS CLI go to the directory where the zip was created and from there execute the command\naws lambda create-function --function-name tutorial --runtime go1.x --role arn:aws:iam::\u0026lt;account\u0026gt;:role/\u0026lt;role name\u0026gt; --handler handler --zip-file \u0026quot;fileb://handler.zip\u0026quot;  This will create a new function in Lambda called tutorial, which uses the Go runtime. The \u0026ndash;role arn:aws:iam:::role/ is the full ARN of the IAM role used to deploy this function. If all went well you\u0026rsquo;ll see a JSON response like this:\n{ \u0026quot;TracingConfig\u0026quot;: { \u0026quot;Mode\u0026quot;: \u0026quot;PassThrough\u0026quot; }, \u0026quot;CodeSha256\u0026quot;: \u0026quot;KzHoXLnTXi9uMugXAOLrMHq6qJ6RimzYdNfrWXIxwLw=\u0026quot;, \u0026quot;FunctionName\u0026quot;: \u0026quot;tutorial\u0026quot;, \u0026quot;CodeSize\u0026quot;: 4026592, \u0026quot;RevisionId\u0026quot;: \u0026quot;94b184e5-74e3-4881-abf5-debad47541b5\u0026quot;, \u0026quot;MemorySize\u0026quot;: 128, \u0026quot;FunctionArn\u0026quot;: \u0026quot;arn:aws:lambda:\u0026lt;region\u0026gt;:\u0026lt;account\u0026gt;:function:tutorial\u0026quot;, \u0026quot;Version\u0026quot;: \u0026quot;$LATEST\u0026quot;, \u0026quot;Role\u0026quot;: \u0026quot;arn:aws:iam::\u0026lt;account\u0026gt;:role/\u0026lt;role\u0026gt;\u0026quot;, \u0026quot;Timeout\u0026quot;: 3, \u0026quot;LastModified\u0026quot;: \u0026quot;2018-05-12T19:30:41.116+0000\u0026quot;, \u0026quot;Handler\u0026quot;: \u0026quot;handler\u0026quot;, \u0026quot;Runtime\u0026quot;: \u0026quot;go1.x\u0026quot;, \u0026quot;Description\u0026quot;: \u0026quot;\u0026quot; }  Testing 1\u0026hellip; 2\u0026hellip; 3\u0026hellip; The only thing left is to test your function. To do that log into AWS and select \u0026ldquo;Lambda\u0026rdquo;, you\u0026rsquo;ll be presented with all the functions you\u0026rsquo;ve deployed so far and one of them will be called tutorial. Click on that, and you\u0026rsquo;ll see the overview of your function, including a large button that says \u0026ldquo;Test\u0026rdquo;. Click \u0026ldquo;Test\u0026rdquo; to configure a new test event. The input for the test event should be\n{ \u0026quot;name\u0026quot;: \u0026quot;World\u0026quot; }  You can replace \u0026ldquo;world\u0026rdquo; with any name or message you want\nFrom there, click \u0026ldquo;Test\u0026rdquo; and the execution logs will display the result\n{ \u0026quot;Hello\u0026quot;: \u0026quot;World\u0026quot; }  And the log output\nSTART RequestId: 2f4086f8-5721-4bf4-b0b7-94cb9d52c709 Version: $LATEST 2019/05/13 13:13:37 Received request: 2f4086f8-5721-4bf4-b0b7-94cb9d52c709 2019/05/13 13:13:37 Payload Type: unknown 2019/05/13 13:13:37 Payload: 'map[name:Matt]' END RequestId: 2f4086f8-5721-4bf4-b0b7-94cb9d52c709 REPORT RequestId: 2f4086f8-5721-4bf4-b0b7-94cb9d52c709\tDuration: 0.76 ms\tBilled Duration: 100 ms Memory Size: 512 MB\tMax Memory Used: 30 MB  As you\u0026rsquo;re glancing over the results, also look at the Duration and Max Memory Used. Isn\u0026rsquo;t that one of the smallest functions you\u0026rsquo;ve seen?!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/contributing/",
	"title": "Contribute",
	"tags": [],
	"description": "",
	"content": " Contribute Discover how you can contribute to Project Flogo!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/contributing/contributing/",
	"title": "Contributing to Project Flogo",
	"tags": [],
	"description": "",
	"content": " Are you interested in contributing to Project Flogo? If so, this doc was created specifically for you! If you‚Äôre not ready to start contributing code, no problem, feel free to check out the documentation issues and begin by helping enhance the documentation!\nDetailed instructions on contributing to the documentation and sharing your projects via the showcase can be found in our documentation, here:\nhttps://tibcosoftware.github.io/flogo/contributing/\nIf you‚Äôre ready and interested to make code contributions, we‚Äôve tried to make the process as easy as possible. First, an automated contributor license agreement (CLA) has been put in place, after your first pull request, you‚Äôll be prompted to sign the agreement, no hassles, easy and integrated right into GitHub. Also, before you begin, take a look at the general guidelines below for contributing.\nHow do I make a contribution? Never made an open source contribution before? Wondering how contributions work in our project? Here\u0026rsquo;s a quick rundown!\nIf you have any questions, feel free to post an issue and tag it as a question, email flogo-oss@tibco.com or chat with the team and community:\n The project-flogo/Lobby Gitter channel should be used for general discussions, start here for all things Flogo! The project-flogo/developers Gitter channel should be used for developer/contributor focused conversations.\n Find an issue that you are interested in addressing or a feature that you would like to add. Look for issues labeled good first issue, kind/help-wanted if you‚Äôre unsure where to begin. Don‚Äôt forget to checkout all of the Flogo repositories: flogo-contrib, flogo-lib, flogo-cli \u0026amp; flogo-services.\n Fork the repository associated with the issue to your local GitHub account. This means that you will have a copy of the repository under github-username/repository-name.\n Clone the repository to your local machine using git clone https://github.com/github-username/repository-name.git.\n Create a new branch for your fix using git checkout -b branch-name-here.\n Make the appropriate changes for the issue you are trying to address or the feature that you want to add.\n Use git add insert-paths-of-changed-files-here to add the file contents of the changed files to the \u0026ldquo;snapshot\u0026rdquo; git uses to manage the state of the project, also known as the index.\n Use git commit -m \u0026quot;Insert a short message of the changes made here\u0026quot; to store the contents of the index with a descriptive message.\n Push the changes to the remote repository using git push origin branch-name-here.\n Submit a pull request to the upstream repository.\n Title the pull request with a short description of the changes made and the issue or bug number associated with your change. For example, you can title an issue like: \u0026ldquo;Registering mapper functions as outlined in #4352\u0026rdquo;.\n In the description of the pull request, explain the changes that you made, any issues you think exist with the pull request you made, and any questions you have for the maintainers.\n Sign the CLA if you have not yet done so in the past.\n Wait for the pull request to be reviewed by a maintainers.\n Make changes to the pull request if the reviewing maintainer recommends them.\n Congratulations, you‚Äôve contributed to Project Flogo, a celebration is in order!\n  Best Practices for Code Contributions If you\u0026rsquo;re adding a new feature, such as an activity or trigger, please follow the best practices below:\n Provide test cases for your feature Package name should match your activity dir. For example, if a new activity is placed in activity/awesomeActivity then the go package name should match.  Follow Go best practices for package names: https://blog.golang.org/package-names  Run gofmt to format your code Leverage activity trigger metadata (activity/trigger.json)  Use metadata ‚Äòrequired‚Äô attribute when the attribute is required Supply a default value in metadata not code (use the value attribute)  Activity Eval() should return true only when completed successfully \u0026amp; err should be returned when an error occurs  Refer to the Flogo Documentation for more guidence and help.\nDon\u0026rsquo;t forget, if you build an awesome Activity or Trigger you can share your work via the Flogo Showcase rather than contributing to flogo-contrib.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/contributing/contribute-to-docs/",
	"title": "Building the docs website",
	"tags": [],
	"description": "",
	"content": " If you want to contribute to the documentation, that is awesome! Your help is very much appreciated, but please do keep in mind the instructions below.\nPrerequisites These documentation pages are built with Hugo and we do make some assumptions:\n You have Git 2.5 or greater installed on your machine. You have a GitHub account. Signing up for GitHub is free. You have Hugo installed on your machine.  In Hugo, pages are the core of your site. Once it is configured, pages are definitely the added value to your documentation site.\nFolders Organize your site like any other Hugo project. Typically, you will have a content folder with all your pages.\ncontent ‚îú‚îÄ‚îÄ level-one ‚îÇ ‚îú‚îÄ‚îÄ level-two ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ level-three ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ level-four ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- /level-one/level-two/level-three/level-four ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-4-a.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-a ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-4-b.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-b ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page-4-c.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-c ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- /level-one/level-two/level-three ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-3-a.md \u0026lt;-- /level-one/level-two/level-three/page-3-a ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-3-b.md \u0026lt;-- /level-one/level-two/level-three/page-3-b ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page-3-c.md \u0026lt;-- /level-one/level-two/level-three/page-3-c ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- /level-one/level-two ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-2-a.md \u0026lt;-- /level-one/level-two/page-2-a ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-2-b.md \u0026lt;-- /level-one/level-two/page-2-b ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page-2-c.md \u0026lt;-- /level-one/level-two/page-2-c ‚îÇ ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- /level-one ‚îÇ ‚îú‚îÄ‚îÄ page-1-a.md \u0026lt;-- /level-one/page-1-a ‚îÇ ‚îú‚îÄ‚îÄ page-1-b.md \u0026lt;-- /level-one/page-1-b ‚îÇ ‚îî‚îÄ‚îÄ page-1-c.md \u0026lt;-- /level-one/page-1-c ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- / ‚îî‚îÄ‚îÄ page-top.md \u0026lt;-- /page-top  _index.md is required in each folder, it‚Äôs your ‚Äúfolder home page‚Äù\n Pages The theme that we\u0026rsquo;re using defines two types of pages. Default and Chapter. Both can be used at any level of the documentation, the only difference being layout display.\nChapters A Chapter displays a page meant to be used as introduction for a set of child pages. Commonly, it contains a simple title and a catch line to define content that can be found under it.\n--- title: Contribute weight: 2 chapter: true --- ### Chapter 2 # Contribute Discover how you can contribute!  To consider a page as a chapter, set chapter=true in the Front Matter of the page.\nDefault pages A Default page is any other content page.\n--- date: 2016-04-09T16:50:16+02:00 title: Advanced display configuration options weight: 40 --- ## Advanced configuration options  Content Now you can add your content (or update existing ones) to the pages that you want.\nBuilding the docs website In order to build and submit your changes, please follow the instructions below:\n Fork the flogo repo Update the docs with your content Create a PR against the flogo repo  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/contributing/contribute-to-showcase/",
	"title": "Contributing to the Showcase",
	"tags": [],
	"description": "",
	"content": " Have an activity, trigger or app that you want to share with the Flogo comunity? That\u0026rsquo;s awesome! To contribute to the showcase follow the steps below.\nFolders The showcase is located at the root of the flogo repo and is structured as follows.\nshowcases ‚îú‚îÄ‚îÄ data ‚îÇ ‚îú‚îÄ‚îÄ items.toml \u0026lt;-- the showcase data file  items.toml is the file that you\u0026rsquo;ll need to edit to add your activity, trigger or app.\n Adding your contribution After you\u0026rsquo;ve forked the flogo repo and cloned it to your local machine, open showcases/data/items.toml in your favorite text editor. You can search to see if your contribution has been listed already or simply append your specific contribution, as shown below.\n[[items]] name = \u0026quot;Aggregate\u0026quot; type = \u0026quot;activity\u0026quot; description = \u0026quot;This activity provides your flogo application with rudimentary aggregation capabilities.\u0026quot; url = \u0026quot;https://github.com/TIBCOSoftware/flogo-contrib/tree/master/activity/aggregate\u0026quot; uploadedon = \u0026quot;January 8, 2018\u0026quot; author = \u0026quot;TIBCOSoftware\u0026quot; showcase = \u0026quot;true\u0026quot;   Enter your contribution name Specify the type: activity, trigger or app Supply a short description Provide the GitHub url Specify your uploaded date Provide your github id display your contribution in the showcase  Building the showcase In order to build and submit your changes, please follow the instructions below:\n Fork the flogo repo Update the showcase with your content, as shown above Create a PR against the flogo repo  Automatic updates Flogo checks for activity updates and new activities once per day and automatically adds them to the items.toml file. By default new additions will not be visible in the showcase, unless the author of the contribution submits a PR to the Flogo repository to do so. Flogo automatically removes contributions that are no longer on GitHub.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": " Flogo terminology and constructs, defined here, all in one place in a logical order vs alphabetical.\nApp An application in Flogo terms is comprised of one or more triggers and flows (actions). The application itself is really just an organizational mechanism that can be leveraged when developing microservices \u0026amp; functions. An application contains a set of configurations, as well as triggers and a collection of flows.\nTrigger Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions (flows).\nTriggers are not coupled to flows, that is, a flow can exist without a trigger.\nHandlers The trigger handler is used to map triggers to actions (flows) for processing. A trigger can have one or more handlers that can route events to different flows.\nAction As stated in the triggers section above, Flogo is an event-driven framework. Incoming events can be mapped to an action. An action is a generic implementation for processing the incoming event. Different types of actions can be implemented, thus defining different methods by which an incoming event can be processed.\nToday, only a single action type has been implemented - the Flow.\nFlow A flow is an implementation of an action and is the primary tool to implement business logic in Flogo. A flow can consist of a number of different constructs:\n One or more activities that implement specific logic (for example write to a database, invoke a REST endpoint, etc) Each activity is connected via a link Links can contain conditional logic to alter the path of a flow  Flows, as previously stated in the triggers section, can exist without a trigger. Thus, flows operate very similar to functions, that is, a single flow can define its own input \u0026amp; output parameters. Thus, enabling a flow to be reused regardless of the trigger entrypoint. All logic in the flow only operates against the following data:\n Flow input parameters Environment variables Application properties The output data from activities referenced in the flow  The flow cannot access trigger data directly, trigger input and output data must be mapped into the flows input and output parameters. Refer to Development \u0026gt; Flows \u0026gt; Mappings\nMapping The phrase mapping occurs quite often and refers to the concept of taking properties from one object and associating them with properties of another object. For example, consider object A exposes two properties and activity B accepts only a single input parameter, the two properties need to be concatenated (for example) and \u0026lsquo;mapped\u0026rsquo; into the single input of activity B.\nActivity An activity is the unit of work that can be leveraged within a Flow. An activity can be any number of things and can be compared to a simple function in Go or any other procedural language, that is, an activity accepts input params and will return one or more objects on return, both input \u0026amp; output params are defined by the activity metadata.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Project Flogo Docs and Tutorials for an Open Source ecosystem for event-driven apps\nGet started...  I\u0026#39;m an App Developer!\n    I\u0026#39;m a Go Developer!\n    I need help!\n     As an App Developer you might want to try...\n Our quickstart\n    Getting started with the Web UI\n    Check out some labs\n     As an Go Developer you might want to try...\n Building your first activity\n    Mapping some fields\n    Deploy a Flogo app to AWS Lambda\n      If you have any questions, feel free to post an issue and tag it as a question, email flogo-oss at tibco dot com or chat with the team and community in:\n Come join our Gitter channel to talk all things Flogo!\n    Join this Gitter channel for developer questions!\n      function show(arg) { document.getElementById(\"app\").classList = \"line hidden\" document.getElementById(\"golang\").classList = \"line hidden\" document.getElementById(\"docs\").classList = \"line hidden\" document.getElementById(\"talk\").classList = \"line hidden\" document.getElementById(arg).classList.remove(\"hidden\") document.getElementById(arg).classList.add(\"block\") }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/api/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Gateway with Javascript This recipe is a gateway which runs some javascript.\nInstallation  Install Go  Setup git clone https://github.com/project-flogo/contrib/activity/jsexec cd jsexec/examples/microgateway/api  Testing Start the gateway:\ngo run example.go  Run the following command:\ncurl http://localhost:9096/calculate\u0026quot;  You should see the following like response:\n{\u0026quot;sum\u0026quot;:3}  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/activities/json/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Gateway with Javascript This recipe is a gateway which runs some javascript.\nInstallation  Install Go Install the Flogo CLI  Setup git clone https://github.com/project-flogo/jsexec cd jsexec/examples/microgateway/json  Testing Create the gateway:\nflogo create -f flogo.json cd MyProxy flogo build  Start the gateway:\nbin/MyProxy  Run the following command:\ncurl http://localhost:9096/calculate\u0026quot;  You should see the following like response:\n{\u0026quot;sum\u0026quot;:3}  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/multi/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Multi-Command Example This example shows how to configure the CLI trigger to run as a cli with multiple commands. Help and version commands are automatically generated for multi-command CLIs.\nTo build and run cli example and execute\nflogo create -f flogo-multi-cli.json cd cli flogo build --shim cli ./bin/cli  Configuration { \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;cli\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;#cli\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;simple\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple CLI Utility\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;usage\u0026quot;:\u0026quot;\u0026lt;command\u0026gt;\u0026quot;, \u0026quot;long\u0026quot;:\u0026quot;A simple cli using flogo\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;name\u0026quot;:\u0026quot;test1\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;usage\u0026quot;:\u0026quot;[flags] [args]\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;test command\u0026quot;, \u0026quot;long\u0026quot;: \u0026quot;the test command\u0026quot;, \u0026quot;flags\u0026quot;: [ \u0026quot;flag1||defaultValue||the first value flag\u0026quot;, \u0026quot;flag2||false||the first bool flag\u0026quot; ] }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:command1\u0026quot; }, \u0026quot;input\u0026quot; :{ \u0026quot;flags\u0026quot;:\u0026quot;=$.flags\u0026quot;, \u0026quot;args\u0026quot;:\u0026quot;=$.args\u0026quot; } } }, { \u0026quot;name\u0026quot;:\u0026quot;test2\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;usage\u0026quot;:\u0026quot;[flags] [args]\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;test2 command\u0026quot;, \u0026quot;long\u0026quot;: \u0026quot;the test2 command\u0026quot;, \u0026quot;flags\u0026quot;: [ \u0026quot;flag1||defaultValue||the first value flag\u0026quot;, \u0026quot;flag2||false||the first bool flag\u0026quot; ] }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:command2\u0026quot; }, \u0026quot;input\u0026quot; :{ \u0026quot;flags\u0026quot;:\u0026quot;=$.flags\u0026quot;, \u0026quot;args\u0026quot;:\u0026quot;=$.args\u0026quot; } } } ] } ] }  Help General Help: cli help\nA simple cli using flogo Usage: cli \u0026lt;command\u0026gt; Commands: test1 test command test2 test2 command help help on command version prints cli version  Command Help: cli help test1\nthe test command Usage: cli test1 [flags] [args] Flags: -flag1 string the first value flag -flag2 the first bool flag  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/development/webui/triggers/single/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Single Command Example This example shows how to configure the CLI trigger to run as a single command. It assumes that there is one handler, which runs by default.\nTo build and run cli example and execute\nflogo create -f flogo-single-cli.json cd cli flogo build --shim cli ./bin/cli  Configuration { \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;cli\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;#cli\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;simple\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple CLI Utility\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;singleCmd\u0026quot;: true }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;test1\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;usage\u0026quot;: \u0026quot;[flags] [args]\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;test command\u0026quot;, \u0026quot;long\u0026quot;: \u0026quot;the test command\u0026quot;, \u0026quot;flags\u0026quot;: [ \u0026quot;flag1||||the first value flag\u0026quot;, \u0026quot;flag2||false||the first bool flag\u0026quot; ] }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:command1\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;flags\u0026quot;: \u0026quot;=$.flags\u0026quot;, \u0026quot;args\u0026quot;: \u0026quot;=$.args\u0026quot; } } } ] } ] }  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/aws-iot/",
	"title": "AWS IoT",
	"tags": [],
	"description": "",
	"content": " A device shadow is a digital representation in the cloud that stores and retrieves current state information for a device. You can get and set the state of a device over MQTT or HTTP, even if the device isn\u0026rsquo;t connected to the Internet.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nCertificates The AWS IoT Device Shadow service requires a very specific setup to make use of SSL certificates. You\u0026rsquo;ll need to download the AWS IoT certificate and private key files. You\u0026rsquo;ll need to put everything in a special folder too, but you\u0026rsquo;ll be able to do that later.\nStep 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to update the device shadow. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. You can create them by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. From there, select Output and configure two parameters:\n Parameter name: code Type: integer  Now click on the + sign to add a new parameter\n Parameter name: message Type: string  Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n Port: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (this can be anything, like /awsiot/status)  After that, click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;message\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well‚Ä¶, saved. You can click the little X on the top-right (no, not your browser‚Ä¶) to close the dialog window and go back to the flow.\nStep 3: Add activities You‚Äôll have to add some acvitivities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type Received Rest request and starting trigger. in the box (on the right hand side of the screen).\nIn the same way you just added the Log activity, now add a Update AWS Device Shadow activity and configure it in the same way with:\n thing: flogo_test (or the name of the device shadow you want to update) awsEndpoint: the MQTT endpoint for your device shadow desired: A JSON representation of the desired state of your device (for example {\u0026quot;switch\u0026quot;:\u0026quot;on\u0026quot;}) reported: A JSON representation of the current state of your device (for example {\u0026quot;switch\u0026quot;:\u0026quot;off\u0026quot;})  This will tell the AWS IoT device shadow to update the reported state into the desired state and as soon as the thing connects to AWS IoT it will receive the new desired state and try to update itself.\nAdd another Log Message activity, but this time with the message Set Report to off and desired to on\nStep 4: Return to sender To complete the app, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200. Now click on \u0026ldquo;a.. message\u0026rdquo; and type \u0026quot;AWS IOT update successful\u0026quot; in the input field (the quotes are needed). Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nWith all the updates, your flow should look something like the one below.\nStep 5: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. Click on build and select your operating system of choice!\nStep 6: Run To run the app you\u0026rsquo;ll need to create on the below structure on disk:\n‚îú‚îÄ‚îÄ \u0026lt;app\u0026gt; \u0026lt;-- Your Flogo app ‚îú‚îÄ‚îÄ things \u0026lt;-- A folder called things ‚îÇ ‚îú‚îÄ‚îÄ root-CA.pem.crt \u0026lt;-- The AWS IoT root certificate (you'll have to rename it to 'root-CA.pem.crt') ‚îÇ ‚îú‚îÄ‚îÄ flogo \u0026lt;-- The name of the thing name (in this case the thing would be called flogo) ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ device.pem.crt \u0026lt;-- The AWS IoT device certificate (you'll have to rename it to 'device.pem.crt') ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ device.pem.key \u0026lt;-- The AWS IoT private key (you'll have to rename it to 'device.pem.key')  After you start the app, you can send POST requests to it like curl --request GET --url http://localhost:9233/awsiot/status --header 'content-type: application/json' --data '{\u0026quot;switch\u0026quot;: \u0026quot;on\u0026quot;}'\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/bookstore/",
	"title": "Bookstore",
	"tags": [],
	"description": "",
	"content": " Who doesn\u0026rsquo;t like a good book? But what if you really, really need to get some information about a book first? In that case you build a Flogo app that uses the Google APIs to get book information!\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nStep 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to update the device shadow. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe thing you need to send to the Google Books API is the isbn coming from the HTTP request. To do so, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;isbn\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. From the screen where you are now, select Output and configure two parameters:\n Parameter name: code Type: integer  Now click on the + sign to add a new parameter\n Parameter name: message Type: any  Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n Port: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /books/:isbn, the :isbn means that you can use that as a path parameter in your mappings).  After that, click on \u0026ldquo;Map to flow inputs\u0026rdquo; to map the isbn from the HTTP trigger to the \u0026ldquo;isbn\u0026rdquo; parameter we created earlier. The parameter will already be selected because it is the only one. You\u0026rsquo;ll need to concatenate isbn: with the actual number so you\u0026rsquo;ll need to type (or paste) the following string.concat(\u0026quot;isbn:\u0026quot;, $.pathParams.isbn).\nNow for the outputs, click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;message\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well‚Ä¶, saved. You can click the little X on the top-right (no, not your browser‚Ä¶) to close the dialog window and go back to the flow.\nStep 3: Adding activities You‚Äôll have to add some acvitivities to the flow for it to do something. To add an activity click on the large + sign\nOn the right-hand side of the screen a list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity using data from all other activities and triggers in your flow. Right now, you only have the incoming data from the HTTP trigger. To make the log message a little more useful you can concatenate things together like in the HTTP trigger. To do so select the concat function from the string category (see #1), which will put a new function in the window. Now replace str1 with \u0026quot;Getting book data for: \u0026quot;, as that will be the first part of the message to log (see #2). The second part will be the isbn. To get the isbn on the place of str2, select str2 first and after that expand the \u0026ldquo;flow (flow)\u0026rdquo; section (by clicking on the little black caret) and click \u0026ldquo;a.. isbn\u0026rdquo; (see #3). That will enter the selected value on the place of str2 (see #4).\nStep 4: Invoking a REST service The Google API for books is a REST service. To invoke a REST service you can add a new Invoke REST Service activity. As you hover over it to configure the values, you\u0026rsquo;ll notice this activity has a lot more fields you can configure. For now the configuration should be:\n method: \u0026quot;GET\u0026quot; (to get data from the API) uri: https://www.googleapis.com/books/v1/volumes (the URL of the service you want to call) queryParams: {\u0026quot;q\u0026quot;:\u0026quot;=$flow.isbn\u0026quot;} (this appends a query parameter called q with the value of the isbn to the URL)  Step 5: Return data To complete the flow, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200.\nNow click on \u0026ldquo;* message\u0026rdquo; and type (or copy) the structure below. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\n{ \u0026quot;title\u0026quot;: \u0026quot;=$activity[rest_3].result.items[0].volumeInfo.title\u0026quot;, \u0026quot;publishedDate\u0026quot;: \u0026quot;=$activity[rest_3].result.items[0].volumeInfo.publishedDate\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;=$activity[rest_3].result.items[0].volumeInfo.description\u0026quot; }  The above snippet maps the values from the REST service to fields that are sent back to the trigger. The mapping is done in a JavaScript-like syntax, so $activity[rest_3].result.items[0].volumeInfo.title means it will get the first result (arrays start with 0) and from that result get the volumeInfo element and from that get the title element. The double curly braces are used as by Go\u0026rsquo;s templating engine.\nYour final flow should look something like the one below.\nStep 6: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026ldquo;\u0026lt;\u0026rdquo; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo;. Choose whichever operating system you\u0026rsquo;re running on to download the executable.\nStep 7: Run To see the results, start your app and run curl --request GET --url http://localhost:9233/books/0747532699. That will give you the details on Harry Potter and the Philosopher\u0026rsquo;s Stone\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/flogo-lambda/",
	"title": "Building Flogo apps for Lambda",
	"tags": [],
	"description": "",
	"content": " Serverless is all around us and perhaps the fastest growing market for compute. Flogo has first class support for AWS Lambda. So you can infinitely scale your ultralight functions and scale back to zero when not in use with AWS Lambda‚Äôs NoOps and seamless scaling capabilities.\nWe‚Äôll guide you through the set of steps required to build the most basic of functions for deployment to AWS Lambda. The flow you‚Äôll build will be the function you deploy.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nAWS CLI To deploy your app at the end of this scenario you\u0026rsquo;ll need the AWS CLI. There are a few ways how you can install the AWS CLI.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you.\nNow you can copy the contents below to the newly created flogo.json file. The Flogo app has a Lambda trigger and a PATH parameter called name.\n{ \u0026quot;name\u0026quot;: \u0026quot;Tutorial\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;start_flow_as_a_function_in_lambda\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/lambda\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Start Flow as a function in Lambda\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Lambda Trigger\u0026quot;, \u0026quot;settings\u0026quot;: {}, \u0026quot;handlers\u0026quot;: [ { \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:lambda_flow\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.evt.name\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;data\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.greeting\u0026quot; } ] } } } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:lambda_flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;LambdaFlow\u0026quot;, \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;any\u0026quot; } ] }, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Log Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;flowInfo\u0026quot;: \u0026quot;false\u0026quot;, \u0026quot;addToFlow\u0026quot;: \u0026quot;false\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;expression\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;string.concat(\\\u0026quot;Hello \\\u0026quot;, $flow.name)\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ] } } }, { \u0026quot;id\u0026quot;: \u0026quot;actreturn_3\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Return\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Return Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/actreturn\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;mappings\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;Hello\u0026quot;: \u0026quot;{{$flow.name}}\u0026quot;} } ] } } } ], \u0026quot;links\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;actreturn_3\u0026quot; } ] } } ] }  Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the flogo cli to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nThe next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source that you can run on AWS Lambda we\u0026rsquo;ll need to execute a command that is very similar to the one we had in the cli tutorial, but with some added parameters. The command you need to run is flogo build -e -shim start_flow_as_a_function_in_lambda, which tells the flogo cli to build the app as an embedded application (the -e option) and with a target shim (the -shim option which uses the trigger id). The AWS Lambda trigger leverages a makefile to kick off the build process, which simply builds your Flogo application using the Lambda trigger shim and zips the binary for deployment to AWS Lambda.\nOnce this command finishes successfully the zip file (handler.zip) will be in the src directory.\nStep 3: AWS Lambda Great! So we\u0026rsquo;ve built the zip that we need to deploy to Lambda and that is exactly what we\u0026rsquo;ll do in this step.\nIAM policies and roles Generally speaking it is a good idea to create separate IAM users for deploying to AWS. This allows you to explicitly control which resources a Lambda function can use. For now, you can make use of any IAM user that has the ability to deploy to AWS Lambda and you\u0026rsquo;ll need the Access Key ID and Secret Access Key for this step.\nAs you go on with building apps for Lambda we do strongly recommend looking atht the AWS IAM documentation to find out which policies you need to set for your IAM user.\nFor this tutorial we\u0026rsquo;ll also assume that you have an IAM role with enough permissions to create a Lambda function. If you\u0026rsquo;ve used the AWS Lambda console, there will likely be an IAM role called lambda_basic_execution which you can use for this tutorial. In any case you\u0026rsquo;ll need the ARN of this role later in this step (which you can find in the IAM console).\nConfigure AWS CLI Run the command aws configure to start the configuration of your AWS CLI. You\u0026rsquo;ll be asked to provide:\n AWS Access Key ID AWS Secret Access Key Default region name (the region you want to deploy to, like us-west-2) Default output format (the output format you want, like json)  Deploy your app To deploy your app go to the directory where the zip was created. From here you can execute the command aws lambda create-function --function-name tutorial --runtime go1.x --role arn:aws:iam::\u0026lt;account\u0026gt;:role/\u0026lt;role name\u0026gt; --handler handler --zip-file \u0026quot;fileb://handler.zip\u0026quot;. This will create a new function in Lambda called tutorial, which uses the Go runtime. The \u0026ndash;role arn:aws:iam:::role/ is the full ARN of the IAM role used to deploy this function. If all went well you\u0026rsquo;ll see a JSON response like this:\n{ \u0026quot;TracingConfig\u0026quot;: { \u0026quot;Mode\u0026quot;: \u0026quot;PassThrough\u0026quot; }, \u0026quot;CodeSha256\u0026quot;: \u0026quot;KzHoXLnTXi9uMugXAOLrMHq6qJ6RimzYdNfrWXIxwLw=\u0026quot;, \u0026quot;FunctionName\u0026quot;: \u0026quot;tutorial\u0026quot;, \u0026quot;CodeSize\u0026quot;: 4026592, \u0026quot;RevisionId\u0026quot;: \u0026quot;94b184e5-74e3-4881-abf5-debad47541b5\u0026quot;, \u0026quot;MemorySize\u0026quot;: 128, \u0026quot;FunctionArn\u0026quot;: \u0026quot;arn:aws:lambda:\u0026lt;region\u0026gt;:\u0026lt;account\u0026gt;:function:tutorial\u0026quot;, \u0026quot;Version\u0026quot;: \u0026quot;$LATEST\u0026quot;, \u0026quot;Role\u0026quot;: \u0026quot;arn:aws:iam::\u0026lt;account\u0026gt;:role/\u0026lt;role\u0026gt;\u0026quot;, \u0026quot;Timeout\u0026quot;: 3, \u0026quot;LastModified\u0026quot;: \u0026quot;2018-05-12T19:30:41.116+0000\u0026quot;, \u0026quot;Handler\u0026quot;: \u0026quot;handler\u0026quot;, \u0026quot;Runtime\u0026quot;: \u0026quot;go1.x\u0026quot;, \u0026quot;Description\u0026quot;: \u0026quot;\u0026quot; }  Step 4: Testing The only thing left is to test your function. To do that log into AWS and select \u0026ldquo;Lambda\u0026rdquo;, you\u0026rsquo;ll be presented with all the functions you\u0026rsquo;ve deployed so far and one of them will be called tutorial. Click on that, and you\u0026rsquo;ll see the overview of your function, including a large button that says \u0026ldquo;Test\u0026rdquo;. Click \u0026ldquo;Test\u0026rdquo; to configure a new test event. The input for the test event should be (you can replace \u0026ldquo;world\u0026rdquo; with any name or message you want)\n{ \u0026quot;name\u0026quot;: \u0026quot;World\u0026quot; }  From there, click \u0026ldquo;Test\u0026rdquo; and the execution logs will display the result\n{ \u0026quot;Hello\u0026quot;: \u0026quot;World\u0026quot; }  And the log output\nSTART RequestId: 4f26990d-561d-11e8-96ca-bb9eb4465310 Version: $LATEST 2018-05-12 19:47:31.969 INFO [trigger-flogo-lambda] - Starting AWS Lambda Trigger 2018/05/12 19:47:31 Starting AWS Lambda Trigger 2018/05/12 19:47:31 Received evt: 'map[name:World]' 2018/05/12 19:47:31 Received ctx: 'map[logStreamName:2018/05/12/[$LATEST]7f886628e07a4256b0f411b6cd3b6915 memoryLimitInMB:128 awsRequestId:4f26990d-561d-11e8-96ca-bb9eb4465310 functionName:tutorial functionVersion:$LATEST logGroupName:/aws/lambda/tutorial]' 2018-05-12 19:47:31.969 INFO [activity-flogo-log] - Hello World $flow.nameEND RequestId: 4f26990d-561d-11e8-96ca-bb9eb4465310 REPORT RequestId: 4f26990d-561d-11e8-96ca-bb9eb4465310\tDuration: 1.63 ms\tBilled Duration: 100 ms Memory Size: 128 MB\tMax Memory Used: 23 MB  As you\u0026rsquo;re glancing over the results, also look at the Duration and Max Memory Used. Isn\u0026rsquo;t that one of the smallest functions you\u0026rsquo;ve seen?!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/flogo-cli/",
	"title": "Building apps with Flogo CLI",
	"tags": [],
	"description": "",
	"content": " Project Flogo provides a CLI that gives you the ability to build flogo applications (flows, streams, rules, microgateway). With this tool you can, among other things, create your applications, build applications and install new extensions. This tool is great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI.\nIn this tutorial you will learn how to use the flogo cli.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you.\nNow you can copy the contents below to the newly created flogo.json file. The Flogo app has a REST trigger which listens on port 9233 and the HTTP path /test/:name (where :name is a parameter you can fill in).\n{ \u0026quot;name\u0026quot;: \u0026quot;SampleApp\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.1.0\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;imports\u0026quot;: [ \u0026quot;github.com/project-flogo/contrib/activity/log\u0026quot;, \u0026quot;github.com/project-flogo/contrib/trigger/rest\u0026quot;, \u0026quot;github.com/project-flogo/flow\u0026quot; ], \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;#rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple REST Trigger\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: 8080 }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/test\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:get_name\u0026quot; }, \u0026quot;input\u0026quot;: { }, \u0026quot;output\u0026quot;: { \u0026quot;code\u0026quot;: 200 } } } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:get_name\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;GetName\u0026quot;, \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ] }, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Logs a message\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;#log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;Hello from Flogo\u0026quot;, \u0026quot;addDetails\u0026quot;: false } } } ] } } ] }  Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the Flogo CLI to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need. The output will look something like:\nflogo create -f /Users/mellis/Downloads/sample_app_1.json myapp Creating Flogo App: myapp Installing: github.com/project-flogo/core@latest Installed trigger: github.com/project-flogo/contrib/trigger/rest Installed action: github.com/project-flogo/flow Installed activity: github.com/project-flogo/contrib/activity/log  The next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nStep 3: Running the app You have just built the Flogo app, so now you can test it. From the bin directory (cd bin) you can run ./myapp which will start the app. In the terminal you\u0026rsquo;ll see something like\n2018-05-12 04:34:56.434 INFO [engine] - Engine Starting... 2018-05-12 04:34:56.435 INFO [engine] - Starting Services... 2018-05-12 04:34:56.435 INFO [engine] - Started Services 2018-05-12 04:34:56.435 INFO [engine] - Starting Triggers... 2018-05-12 04:34:56.435 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-05-12 04:34:56.435 INFO [engine] - Triggers Started 2018-05-12 04:34:56.435 INFO [engine] - Engine Started  To test it we\u0026rsquo;ll use the curl command line tool, which is installed on most Operating Systems. From a new terminal window execute the command curl http://localhost:8080/test. It will send an HTTP request to the app on port 8080 (which was configured in the flogo.json file). In the first terminal you will see the result of the flow (Hello from Flogo), you\u0026rsquo;ll also see there are additional lines in your window that indicate a flow has been executed.\n2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tStarting app [ SampleApp ] with version [ 0.0.1 ] 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tEngine Starting... 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tStarting Services... 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tActionRunner Service: Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tStarted Services 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tStarting Application... 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tStarting Triggers... 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tTrigger [ receive_http_message ]: Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tTriggers Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tApplication Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo.engine] -\tEngine Started 2019-05-13T17:40:14.851+0200\tINFO\t[flogo] -\tListening on http://0.0.0.0:8080 2019-05-13T17:40:33.456+0200\tINFO\t[flogo.activity.log] -\tHello from Flogo 2019-05-13T17:40:33.456+0200\tINFO\t[flogo.flow] -\tInstance [28ac8005732b92373635a219624031dd] Done  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/building-activities/",
	"title": "Building your first activity",
	"tags": [],
	"description": "",
	"content": " Project Flogo exposes a number of different extension points, in this tutorial we\u0026rsquo;ll explore the activity contribution point and learn how to build a custom activity in Go.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Generate the basic framework The easiest way to start creating activities is to clone the content of the project-flogo/core/examples/activity. In this tutorial you\u0026rsquo;ll build an activity that takes 2 input parameters (name and salutation) and logs that to the console. It will also return the concatenation of the two fields to you. To start you should pull the example activity from flogo core:\ngit clone https://github.com/project-flogo/core cp -R core/examples/activity/* /myNewActivity  The metadata The first step is to update the file descriptor.json, which has the metadata for your new Flogo activity, with proper information. The metadata describes to the Flogo Web UI what the activity is called, what the version of the activity is and a few other things, such as the input and output. The elements in the file are:\n name: The name of the activity (this should match the name of the folder the activity is in, like HelloWorld) version: The version of the activity (it is recommended to use semantic versioning for your activities) type: This describes the type of contribution this is (this should be flogo:activity in this case) title: The application title to display in the web ui ref: The Go package reference that will be used by the web ui to fetch the contribution upon installation description: A brief description of your activity (this is displayed in the Flogo Web UI) author: This is you! settings: An array of name/type pairs that describe the activity settings. Note that activity settings are pre-compiled settings and can be used to increased performance. Settings are not fetched for every invocation input: An array of name/type pairs that describe the input to the activity output: An array of name/type pairs that describe the output to the activity  Since you\u0026rsquo;ll want to provide some inputs, you\u0026rsquo;ll need to update the inputs and outputs section\n The input needs a anInput param (should be of type string) The output section needs a parameter called anOutput (should be of type string)  Don\u0026rsquo;t forget to update the author, ref, and description fields, as well! For Flogo Web UI, add a title field to label and help find your activity.\n The updated descriptor.json will look quite similar to the below one.\n{ \u0026quot;name\u0026quot;: \u0026quot;sample-activity\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:activity\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;Sample Activity\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample Activity\u0026quot;, \u0026quot;homepage\u0026quot;: \u0026quot;https://github.com/project-flogo/tree/master/examples/activity\u0026quot;, \u0026quot;settings\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;aSetting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;required\u0026quot;: true } ], \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;anInput\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;required\u0026quot;: true } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;anOutput\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ]  The logic For the Flogo engine to actually do something we need to update the *.go files. There are two files in your current directory:\n activity.go: which contains the actual activity implementation in go activity_test.go: which contains unit tests for the activity metadata.go: which contains the basic input/output/settings metadata. This is used by the engine  The first step is to define our input/output/setting metadata.go. This is used by the engine and also used when leveraging contributions using the Flogo Go Lib. This enables Go developers to leverage strongly typed objects for IDE autocompletion, etc.\npackage sample import \u0026quot;github.com/project-flogo/core/data/coerce\u0026quot; type Settings struct { ASetting string `md:\u0026quot;aSetting,required\u0026quot;` } type Input struct { AnInput string `md:\u0026quot;anInput,required\u0026quot;` } func (r *Input) FromMap(values map[string]interface{}) error { strVal, _ := coerce.ToString(values[\u0026quot;anInput\u0026quot;]) r.AnInput = strVal return nil } func (r *Input) ToMap() map[string]interface{} { return map[string]interface{}{ \u0026quot;anInput\u0026quot;: r.AnInput, } } type Output struct { AnOutput string `md:\u0026quot;anOutput\u0026quot;` } func (o *Output) FromMap(values map[string]interface{}) error { strVal, _ := coerce.ToString(values[\u0026quot;anOutput\u0026quot;]) o.AnOutput = strVal return nil } func (o *Output) ToMap() map[string]interface{} { return map[string]interface{}{ \u0026quot;anOutput\u0026quot;: o.AnOutput, } }  The next step is to look at the business logic, in the activity.go file.\npackage sample import ( \u0026quot;github.com/project-flogo/core/activity\u0026quot; \u0026quot;github.com/project-flogo/core/data/metadata\u0026quot; ) func init() { _ = activity.Register(\u0026amp;Activity{}) //activity.Register(\u0026amp;Activity{}, New) to create instances using factory method 'New' } var activityMd = activity.ToMetadata(\u0026amp;Settings{}, \u0026amp;Input{}, \u0026amp;Output{}) //New optional factory method, should be used if one activity instance per configuration is desired func New(ctx activity.InitContext) (activity.Activity, error) { s := \u0026amp;Settings{} err := metadata.MapToStruct(ctx.Settings(), s, true) if err != nil { return nil, err } ctx.Logger().Debugf(\u0026quot;Setting: %s\u0026quot;, s.ASetting) act := \u0026amp;Activity{} //add aSetting to instance return act, nil } // Activity is an sample Activity that can be used as a base to create a custom activity type Activity struct { } // Metadata returns the activity's metadata func (a *Activity) Metadata() *activity.Metadata { return activityMd } // Eval implements api.Activity.Eval - Logs the Message func (a *Activity) Eval(ctx activity.Context) (done bool, err error) { input := \u0026amp;Input{} err = ctx.GetInputObject(input) if err != nil { return true, err } ctx.Logger().Debugf(\u0026quot;Input: %s\u0026quot;, input.AnInput) output := \u0026amp;Output{AnOutput: input.AnInput} err = ctx.SetOutputObject(output) if err != nil { return true, err } return true, nil }  To make sure that you can test and build the new activity, you\u0026rsquo;ll need to go get (pun intended) a few packages\ngo get github.com/project-flogo/core/activity go get github.com/project-flogo/core/data/coerce go get github.com/project-flogo/core/data/metadata  Unit testing You\u0026rsquo;ve just completed the logic of the activity and, following best practice, you should have an automated way to test the activity to make sure that the it works and so that other developers can run the same tests to validate the output as well. The activity_test.go file looks like:\npackage sample import ( \u0026quot;testing\u0026quot; \u0026quot;github.com/project-flogo/core/activity\u0026quot; \u0026quot;github.com/project-flogo/core/support/test\u0026quot; \u0026quot;github.com/stretchr/testify/assert\u0026quot; ) func TestRegister(t *testing.T) { ref := activity.GetRef(\u0026amp;Activity{}) act := activity.Get(ref) assert.NotNil(t, act) } func TestEval(t *testing.T) { act := \u0026amp;Activity{} tc := test.NewActivityContext(act.Metadata()) input := \u0026amp;Input{AnInput: \u0026quot;test\u0026quot;} err := tc.SetInputObject(input) assert.Nil(t, err) done, err := act.Eval(tc) assert.True(t, done) assert.Nil(t, err) output := \u0026amp;Output{} err = tc.GetOutputObject(output) assert.Nil(t, err) assert.Equal(t, \u0026quot;test\u0026quot;, output.AnOutput) }  In order to run the test cases you\u0026rsquo;ll need to intall two more packages. One to be able to run the tests and one to be able to create assertions.\ngo get github.com/project-flogo/core/activity go get github.com/project-flogo/core/support/test go get github.com/stretchr/testify/assert  To run all the test cases for your activity, in this case just one, simply enter\ngo test  and if all goes well the result should look like\nPASS ok _/C_/tools/gosrc/HelloWorld 0.051s  Use your new activity in a flow Now the only thing left to do is use the activity inside a Flogo app! You have two options, install the new activity using the Flogo CLI or via the Web UI. In any case you\u0026rsquo;ll first want to publish your activity to a Git repo (the same one you\u0026rsquo;ve used in the ref field in the descriptor.json). To add the new activity to a Flogo engine and use it in a flow you can import it using the following flogo CLI command, from your flow app directory):\nflogo install github.com/yourusername/yourrepository  or import it using the \u0026ldquo;Install new activity\u0026rdquo; option in the Flogo Web UI, where you\u0026rsquo;ll need to provide the URL https://github.com/yourusername/yourrepository.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/building-triggers/",
	"title": "Building your first trigger",
	"tags": [],
	"description": "",
	"content": " Project Flogo provides two different command-line interfaces and which you need depends on the task you need to execute.\n flogo: This CLI gives you the ability to build flows and microservices. With this tool you can, among other things, create your applications, build applications and install new extensions. This tool is great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI. flogogen: If you‚Äôre looking to extend the functionality that Project Flogo offers out of the box, this is the tool you want to use. Flogogen generates the scafolding used by extensions (activity/trigger) developers to build new extensions.  In this tutorial you will learn how to use the flogogen tool.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Generate the basic framework The easiest way to start creating activities is to have the flogogen CLI create the basic framework for you. The flogogen CLI takes two important parameters to create the framework for triggers. Timers are great to schedule stuff, and a great way to learn new technology, so in this tutorial you\u0026rsquo;ll build a new timer trigger that runs on a specified interval. To start you need to use flogogen to create the scaffolding:\nflogogen trigger \u0026lt; name \u0026gt;  The parameters are:\n trigger: because you want to create a trigger \u0026lt; name \u0026gt;: the name for your new trigger (in this example you\u0026rsquo;ll use MyTimerTrigger as the name for the trigger to make sure it doesn\u0026rsquo;t clash with the existing timer)  So to generate our scaffolding, you need to execute the command:\nflogogen trigger MyTimerTrigger  The flogogen command will create a folder called MyTimerTrigger and generate the files you need to implement your logic:\nMyTimerTrigger ‚îú‚îÄ‚îÄ trigger.go \u0026lt;-- The implementation of your trigger ‚îú‚îÄ‚îÄ trigger.json \u0026lt;-- The metadata of your trigger ‚îî‚îÄ‚îÄ trigger_test.go \u0026lt;-- A file used to test your trigger  The metadata The first step is to update the file trigger.json, which has the metadata for your new Flogo activity, with proper information. The metadata describes to the Flogo engine what the activity is called, what the version of the activity is and a few other things. The elements in the file are:\n name: The name of the activity (this should match the name of the folder the activity is in, like MyTimerTrigger) version: The version of the activity (it is recommended to use semantic versioning for your trigger) type: This describes to the Flogo engine what kind of contribution this is (this should be trigger in this case) ref: The Flogo engine is based on Go and this field is the \u0026ldquo;import\u0026rdquo; path for Go apps (generally speaking this should match your repository) description: A brief description of your activity (this is displayed in the Flogo Web UI) author: This is you! settings: An array of name/type pairs that describe global settings of the trigger (configuration that will be the same for every instance of this trigger used in your app) output: An array of name/type pairs that describe the output of the trigger (the data that gets sent to your flow) handler: An array of name/type pairs that describe flow specific settings of the trigger (configuration that will be unique for every instance of this trigger used in your app)  Since you\u0026rsquo;ll want to provide some configuration, you\u0026rsquo;ll need to update the outputs section\n The settings section will be left empty (you\u0026rsquo;ll use flow specific settings) The output section needs a parameter called output (should be of type string) The handler/settings section needs a parameter called seconds (should be of type string)  Don\u0026rsquo;t forget to update the author, ref, and description fields, as well!\n The updated trigger.json will look quite similar to the below one.\n{ \u0026quot;name\u0026quot;: \u0026quot;MyTimerTrigger\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:trigger\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;This is a new Timer\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/yourusername/yourrepository\u0026quot;, \u0026quot;author\u0026quot;: \u0026quot;Flogo Dev\u0026quot;, \u0026quot;settings\u0026quot;:[ ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;output\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;handler\u0026quot;: { \u0026quot;settings\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;seconds\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ] } }  The logic For the Flogo engine to actually do something we need to update the *.go files. There are two files in your current directory:\n trigger.go: which contains the actual trigger implementation in go trigger_test.go: which contains unit tests for the trigger  The first step is to look at the business logic, in the trigger.go file.\nTo begin there are a few packages you\u0026rsquo;ll need to import to make sure the code will work:\n\u0026quot;context\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/core/trigger\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/logger\u0026quot; \u0026quot;github.com/carlescere/scheduler\u0026quot;  As you want to log output to the console you\u0026rsquo;ll need to add a new variable called log to the main part of the file\n// Create a new logger var log = logger.GetLogger(\u0026quot;trigger-mytrigger\u0026quot;)  The struct called MyTrigger needs a few more fields to keep track of all the different elements it needs to know about. You\u0026rsquo;ll need to add the timers and handlers so that the engine knows which timers exist and which flows to call when a timer runs.\n// MyTrigger is a stub for your Trigger implementation type MyTrigger struct { metadata *trigger.Metadata config *trigger.Config timers []*scheduler.Job handlers []*trigger.Handler }  In the Initialize method you\u0026rsquo;ll need to add one statement to make sure that the trigger can get all the handlers it should know about from the context object.\nt.handlers = ctx.GetHandlers()  The Start method implements the logic required to start the various timers you might create in your app and for each it will schedule a job (using the scheduleRepeating method)\n// Start implements trigger.Trigger.Start func (t *MyTrigger) Start() error { log.Debug(\u0026quot;Start\u0026quot;) handlers := t.handlers log.Debug(\u0026quot;Processing handlers\u0026quot;) for _, handler := range handlers { t.scheduleRepeating(handler) } return nil }  The scheduleRepeating method is used to schedule a repeating job with a specified time interval. The variable called fn2 is executed when a timer fires and calls the flow it should trigger with the data specified in the map triggerData. The map contains a field called output which matches the name in the trigger.json file.\nfunc (t *MyTrigger) scheduleRepeating(endpoint *trigger.Handler) { log.Info(\u0026quot;Scheduling a repeating job\u0026quot;) fn2 := func() { // Create a map to hold the trigger data triggerData := map[string]interface{}{ \u0026quot;output\u0026quot;: \u0026quot;Hello World from the new Timer Trigger\u0026quot;, } _, err := endpoint.Handle(context.Background(), triggerData) if err != nil { log.Error(\u0026quot;Error running handler: \u0026quot;, err.Error()) } } t.scheduleJobEverySecond(endpoint, fn2) }  Finally, you\u0026rsquo;ll need to add a method called scheduleJobEverySecond to make sure the engine checks the timers on a regular basis and executes the function to trigger a flow.\nfunc (t *MyTrigger) scheduleJobEverySecond(tgrHandler *trigger.Handler, fn func()) { var interval int = 0 seconds, _ := strconv.Atoi(tgrHandler.GetStringSetting(\u0026quot;seconds\u0026quot;)) interval = interval + seconds log.Debug(\u0026quot;Repeating seconds: \u0026quot;, interval) // schedule repeating timerJob, err := scheduler.Every(time.Duration(interval)).Seconds().Run(fn) if err != nil { log.Error(\u0026quot;Error scheduleRepeating (repeat seconds) flo err: \u0026quot;, err.Error()) } if timerJob == nil { log.Error(\u0026quot;timerJob is nil\u0026quot;) } t.timers = append(t.timers, timerJob) }  The completed file will look something like:\npackage MyTimerTrigger import ( \u0026quot;context\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/core/trigger\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/logger\u0026quot; \u0026quot;github.com/carlescere/scheduler\u0026quot; ) // Create a new logger var log = logger.GetLogger(\u0026quot;trigger-mytrigger\u0026quot;) // MyTriggerFactory My Trigger factory type MyTriggerFactory struct { metadata *trigger.Metadata } // NewFactory create a new Trigger factory func NewFactory(md *trigger.Metadata) trigger.Factory { return \u0026amp;MyTriggerFactory{metadata: md} } // New Creates a new trigger instance for a given id func (t *MyTriggerFactory) New(config *trigger.Config) trigger.Trigger { return \u0026amp;MyTrigger{metadata: t.metadata, config: config} } // MyTrigger is a stub for your Trigger implementation type MyTrigger struct { metadata *trigger.Metadata config *trigger.Config timers []*scheduler.Job handlers []*trigger.Handler } // Initialize implements trigger.Init.Initialize func (t *MyTrigger) Initialize(ctx trigger.InitContext) error { t.handlers = ctx.GetHandlers() return nil } // Metadata implements trigger.Trigger.Metadata func (t *MyTrigger) Metadata() *trigger.Metadata { return t.metadata } // Start implements trigger.Trigger.Start func (t *MyTrigger) Start() error { log.Debug(\u0026quot;Start\u0026quot;) handlers := t.handlers log.Debug(\u0026quot;Processing handlers\u0026quot;) for _, handler := range handlers { t.scheduleRepeating(handler) } return nil } // Stop implements trigger.Trigger.Start func (t *MyTrigger) Stop() error { // stop the trigger return nil } func (t *MyTrigger) scheduleRepeating(endpoint *trigger.Handler) { log.Info(\u0026quot;Scheduling a repeating job\u0026quot;) fn2 := func() { // Create a map to hold the trigger data triggerData := map[string]interface{}{ \u0026quot;output\u0026quot;: \u0026quot;Hello World from the new Timer Trigger\u0026quot;, } _, err := endpoint.Handle(context.Background(), triggerData) if err != nil { log.Error(\u0026quot;Error running handler: \u0026quot;, err.Error()) } } t.scheduleJobEverySecond(endpoint, fn2) } func (t *MyTrigger) scheduleJobEverySecond(tgrHandler *trigger.Handler, fn func()) { var interval int = 0 seconds, _ := strconv.Atoi(tgrHandler.GetStringSetting(\u0026quot;seconds\u0026quot;)) interval = interval + seconds log.Debug(\u0026quot;Repeating seconds: \u0026quot;, interval) // schedule repeating timerJob, err := scheduler.Every(time.Duration(interval)).Seconds().Run(fn) if err != nil { log.Error(\u0026quot;Error scheduleRepeating (repeat seconds) flo err: \u0026quot;, err.Error()) } if timerJob == nil { log.Error(\u0026quot;timerJob is nil\u0026quot;) } t.timers = append(t.timers, timerJob) }  To make sure that you can test and build the new trigger, you\u0026rsquo;ll need to go get (pun intended) a few packages\ngo get github.com/TIBCOSoftware/flogo-lib/core/trigger go get github.com/TIBCOSoftware/flogo-lib/logger go get github.com/carlescere/scheduler  Use your new trigger in a flow Now the only thing left to do is use the trigger inside a Flogo app! You have two options, install the new trigger using the Flogo CLI or via the Web UI. In any case you\u0026rsquo;ll first want to publish your trigger to a Git repo (the same one you\u0026rsquo;ve used in the ref field in the trigger.json). To add the new trigger to a Flogo engine and use it in a flow you can import it using the following flogo CLI command, from your flow app directory):\nflogo install github.com/yourusername/yourrepository  or import it using the \u0026ldquo;Install new trigger\u0026rdquo; option in the Flogo Web UI, where you\u0026rsquo;ll need to provide the URL https://github.com/yourusername/yourrepository.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/cheesecake-service/",
	"title": "Cheesecake Service",
	"tags": [],
	"description": "",
	"content": " Project Flogo offers multiple ways to build apps:\n Web UI: You can develop flows using a zero code Web UI, which allows you to graphically build your microservices; JSON DSL: You can also build an app using a sophisticated, but elegant, JSON DSL (the Web UI uses this internally as well!); Go API: You can use the Go API to use Flogo as a Librry in your Go app!  In this tutorial you will learn how to use Flogo as a Library and to build a Go app while leveraging the Flogo engine. The tutorial makes use of the REST trigger as well as the Log activity.\nWhat you\u0026rsquo;ll need Go This demo makes use of Go. If you haven\u0026rsquo;t installed Go yet, check out how to install it here. You\u0026rsquo;ll need Go 1.9.x or higher for this tutorial.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: Outline The service you\u0026rsquo;ll build needs a file in which to code. The steps will walk you through the creation of the file and walk through the entire source code, to make sure you add all the right things you need for the cheesecake servuce. To get started, create a file called main.go, which will be the main file of the cheesecake service.\ntouch main.go  A Go app that uses Flogo as a Library isn\u0026rsquo;t any different from a regular Go app, with one subtle addition right at the beginning of the file. Since the Flogo engine requires metadata of each activity you\u0026rsquo;ll need to make sure that the Go compiler creates, and packages, that metadata as well. To do so, add the below line as the first line in your file\n//go:generate go run $GOPATH/src/github.com/TIBCOSoftware/flogo-lib/flogo/gen/gen.go $GOPATH  This line will tell go what to do when running the generate command. The generate command runs commands described by directives within existing files. Those commands can run any process but the intent is to create or update Go source files and in this case it generates the metadata files for your service.\nStep 2: Imports To make the app work, you\u0026rsquo;ll need a few imports\npackage main import ( // Default Go packages \u0026quot;context\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strconv\u0026quot; // The Flogo Log activity \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot; // The Flogo REST trigger \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot; // Core packages for the Flogo engine \u0026quot;github.com/TIBCOSoftware/flogo-lib/core/data\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/engine\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/flogo\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/logger\u0026quot; )  Just like with any Go package, the Go compiler needs to have access to them to be able to compile the program into an executable. To make sure the packages are available, you\u0026rsquo;ll need to run\ngo get -u github.com/TIBCOSoftware/flogo-contrib/activity/log go get -u github.com/TIBCOSoftware/flogo-contrib/trigger/rest go get -u github.com/TIBCOSoftware/flogo-lib/core/data go get -u github.com/TIBCOSoftware/flogo-lib/engine go get -u github.com/TIBCOSoftware/flogo-lib/flogo go get -u github.com/TIBCOSoftware/flogo-lib/logger  Step 3: Variables Hard coding variables is never a good idea. As you\u0026rsquo;re building an app that uses the HTTP trigger, you\u0026rsquo;ll want to make sure that the HTTP port is configurable. To do so add the below directive to your main.go file\nvar ( httpport = os.Getenv(\u0026quot;HTTPPORT\u0026quot;) )  The app will now be able to use an environment variable called HTTPPORT as the port for the HTTP trigger\nStep 4: Main Every app needs a main function as the entry point into the program, and a Flogo app isn\u0026rsquo;t any different. The main function in the case of a Go app that uses Flogo as a Library, might look a little different:\nfunc main() { // Create a new Flogo app app := appBuilder() e, err := flogo.NewEngine(app) if err != nil { logger.Error(err) return } engine.RunEngine(e) }  The first line creates the app (using a method you\u0026rsquo;ll define in the next step). The lines after that create the Flogo engine and instruct the engine to run the app.\nStep 5: The app The Flogo engine needs an app to run, and to construct that app you\u0026rsquo;ll need another method\nfunc appBuilder() *flogo.App { app := flogo.NewApp() // Convert the HTTPPort to an integer port, err := strconv.Atoi(httpport) if err != nil { logger.Error(err) } // Register the HTTP trigger trg := app.NewTrigger(\u0026amp;rest.RestTrigger{}, map[string]interface{}{\u0026quot;port\u0026quot;: port}) trg.NewFuncHandler(map[string]interface{}{\u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/cheesecake/:name\u0026quot;}, Handler) return app }  The first line constructs the app, that will be returned as the result of this method. The next step is to convert the HTTPPORT variable from a string into an integer. The last part, before the return, is creating the HTTP trigger. In this section you create a new trigger using a method call with two parameters:\n The trigger type: \u0026amp;rest.RestTrigger{} The settings: map[string]interface{}{\u0026quot;port\u0026quot;: port} (if you check the trigger.json, you\u0026rsquo;ll see the port field is a global setting)  After that, you\u0026rsquo;ll need to register a function handler for each of the HTTP methods and PATHs you want to handle. In this case the app will handle a GET operation for the path /cheesecake/:name (where :name is a PATH parameter) and as events come in for this path, it will dispatch them to a method called Handler.\nStep 6: The Handler The next step is that your app needs to handle the events and to do so, you\u0026rsquo;ll need to create a method called Handler:\n// Handler is the function that gets executed when the engine receives a message func Handler(ctx context.Context, inputs map[string]*data.Attribute) (map[string]*data.Attribute, error) { // Get the name from the path name := inputs[\u0026quot;pathParams\u0026quot;].Value().(map[string]string)[\u0026quot;name\u0026quot;] // Log, using the Flogo log activity // There are definitely better ways to do this with Go, but we want to show how to use activities in := map[string]interface{}{\u0026quot;message\u0026quot;: name, \u0026quot;flowInfo\u0026quot;: \u0026quot;true\u0026quot;, \u0026quot;addToFlow\u0026quot;: \u0026quot;true\u0026quot;} _, err := flogo.EvalActivity(\u0026amp;log.LogActivity{}, in) if err != nil { return nil, err } // Set the result message var cheesecake string switch name { case \u0026quot;retgits\u0026quot;: cheesecake = \u0026quot;Likes all cheesecakes\u0026quot; case \u0026quot;flynn\u0026quot;: cheesecake = \u0026quot;Prefers some nectar!\u0026quot; default: cheesecake = \u0026quot;Plain cheesecake is the best\u0026quot; } // The return message is a map[string]*data.Attribute which we'll have to construct response := make(map[string]interface{}) response[\u0026quot;name\u0026quot;] = name response[\u0026quot;cheesecake\u0026quot;] = cheesecake ret := make(map[string]*data.Attribute) ret[\u0026quot;code\u0026quot;], _ = data.NewAttribute(\u0026quot;code\u0026quot;, data.TypeInteger, 200) ret[\u0026quot;data\u0026quot;], _ = data.NewAttribute(\u0026quot;data\u0026quot;, data.TypeAny, response) return ret, nil }  From top to bottom the code does the following:\n1) Get the name from the PATH parameter; 2) Execute the log activity (the inputs passed in as a map[string]interface{} are the same fields as in the activity.json); 3) Use a regular Go switch statement to determine the favorite cheesecake based on the name; 4) Create a map[string]interface{} with the return values of the app; 5) Return an HTTP statuscode and the message.\nStep 7: Complete app Right now, your complete app should look like\n//go:generate go run $GOPATH/src/github.com/TIBCOSoftware/flogo-lib/flogo/gen/gen.go $GOPATH package main import ( // Default Go packages \u0026quot;context\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strconv\u0026quot; // The Flogo Log activity \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot; // The Flogo REST trigger \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot; // Core packages for the Flogo engine \u0026quot;github.com/TIBCOSoftware/flogo-lib/core/data\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/engine\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/flogo\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/logger\u0026quot; ) var ( httpport = os.Getenv(\u0026quot;HTTPPORT\u0026quot;) ) func main() { // Create a new Flogo app app := appBuilder() e, err := flogo.NewEngine(app) if err != nil { logger.Error(err) return } engine.RunEngine(e) } func appBuilder() *flogo.App { app := flogo.NewApp() // Convert the HTTPPort to an integer port, err := strconv.Atoi(httpport) if err != nil { logger.Error(err) } // Register the HTTP trigger trg := app.NewTrigger(\u0026amp;rest.RestTrigger{}, map[string]interface{}{\u0026quot;port\u0026quot;: port}) trg.NewFuncHandler(map[string]interface{}{\u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/cheesecake/:name\u0026quot;}, Handler) return app } // Handler is the function that gets executed when the engine receives a message func Handler(ctx context.Context, inputs map[string]*data.Attribute) (map[string]*data.Attribute, error) { // Get the name from the path name := inputs[\u0026quot;pathParams\u0026quot;].Value().(map[string]string)[\u0026quot;name\u0026quot;] // Log, using the Flogo log activity // There are definitely better ways to do this with Go, but we want to show how to use activities in := map[string]interface{}{\u0026quot;message\u0026quot;: name, \u0026quot;flowInfo\u0026quot;: \u0026quot;true\u0026quot;, \u0026quot;addToFlow\u0026quot;: \u0026quot;true\u0026quot;} _, err := flogo.EvalActivity(\u0026amp;log.LogActivity{}, in) if err != nil { return nil, err } // Set the result message var cheesecake string switch name { case \u0026quot;retgits\u0026quot;: cheesecake = \u0026quot;Likes all cheesecakes\u0026quot; case \u0026quot;flynn\u0026quot;: cheesecake = \u0026quot;Prefers some nectar!\u0026quot; default: cheesecake = \u0026quot;Plain cheesecake is the best\u0026quot; } // The return message is a map[string]*data.Attribute which we'll have to construct response := make(map[string]interface{}) response[\u0026quot;name\u0026quot;] = name response[\u0026quot;cheesecake\u0026quot;] = cheesecake ret := make(map[string]*data.Attribute) ret[\u0026quot;code\u0026quot;], _ = data.NewAttribute(\u0026quot;code\u0026quot;, data.TypeInteger, 200) ret[\u0026quot;data\u0026quot;], _ = data.NewAttribute(\u0026quot;data\u0026quot;, data.TypeAny, response) return ret, nil }  Step 7: Build To build the app, you\u0026rsquo;ll need to run two commands:\n// Make sure that the metadata is generated go generate // Build the app go build -o cheesecakesvc  Because you\u0026rsquo;re using Flogo as a Library in your app, you don\u0026rsquo;t need to use the flogo build command but instead use the regular go build with any parameters you might want to pass in (-o cheesecakesvc means the output will be an executable called cheesecakesvc).\nStep 8: Run To run the app simply run\nHTTPPORT=8888 ./cheesecakesvc  And in a separate terminal run to see the result of your app\n$ curl --request GET --url http://localhost:8888/cheesecake/retgits {\u0026quot;cheesecake\u0026quot;:\u0026quot;Likes all cheesecakes\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;retgits\u0026quot;}  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/cloudfoundry/",
	"title": "Cloud Deployments: Cloud Foundry",
	"tags": [],
	"description": "",
	"content": " Cloud Foundry is an open-source platform as a service (PaaS) that provides you with a choice of clouds, developer frameworks, and application services.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nCloud Foundry If you want to run Flogo apps in a Cloud Foundry environment, you have two options:\n Using the binary buildpack Using docker containers  If you want to try out Pivotal Cloud Foundry, you might to check out PCF Dev and follow the first three steps to get your environment up and running.\n Using the binary buildpack With the Cloud Foundry Binary Buildpack you can run arbitrary binary web servers on Cloud Foundry without the need to have a specific build pack for that language. Since Flogo can compile down to a binary, this saves you from installing additional buildpacks. There are a few prerequisites you need to take into account though:\n You\u0026rsquo;ll need a binary that is able to run on the same OS as CF is deployed (most likely Linux, which you can do with env GOOS=linux flogo build) You\u0026rsquo;ll need to make sure you\u0026rsquo;re using port 8080 for your Receive HTTP Message trigger  Steps to deploy:\n Make sure the app is executable: chmod +x \u0026lt;appname\u0026gt; Push to PCF: cf push \u0026lt;name in pcf\u0026gt; -c './\u0026lt;appname\u0026gt;' -b binary_buildpack  For more detailed information and more flags you can set during deployments, check Binary Buildpack in the Cloud Foundry docs.\nUsing docker  By default, apps deployed with the cf push command run in standard Cloud Foundry Linux containers. With Docker support enabled, Cloud Foundry can also deploy and manage apps running in Docker containers.\n To enable docker support an administrator has to run:\ncf enable-feature-flag diego_docker  For example, the below command would push and run the Project Flogo Web UI on Cloud Foundry\ncf push my-app --docker-image flogo/flogo-docker  For more detailed information and more flags you can set during deployments, check Deploy an App with Docker in the Cloud Foundry docs.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/docker/",
	"title": "Cloud Deployments: Docker",
	"tags": [],
	"description": "",
	"content": " Flogo apps are ultralight so building docker images is not only really easy, because it can embed all dependencies it can also run inside of super small docker containers.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nUsing flogo Out of the box, Flogo has the option to build a docker container from the app.\nflogo build -e -docker \u0026lt;trigger id\u0026gt;  The above command will build a Flogo app, with embedded configuration (-e), and create a docker image where it can expose the PORT based on which trigger ID you specify. If you don\u0026rsquo;t want to expose a port (for example, because you start with a timer) you can specify no-trigger as the trigger id.\nThe docker file it generates and uses to build the docker image is:\n# Dockerfile for {{.name}} # VERSION {{.version}} FROM alpine RUN apk update \u0026amp;\u0026amp; apk add ca-certificates ADD {{.name}}-linux-amd64 . EXPOSE {{.port}} CMD ./{{.name}}-linux-amd64`  note that {{.name}} and {{.port}} are substitution variables coming from the configuration of your app\n After building the image you can run the container using the docker run command\nDo-It-Yourself While practical, you don\u0026rsquo;t have to rely on flogo to generate the docker image for you. If you prefer to construct the Dockerfile yourself, that is perfectly okay too. The flogo cli simply wraps the command:\ndocker build . -t \u0026lt;app name\u0026gt;:\u0026lt;app version\u0026gt;  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/cicd-for-activities/",
	"title": "Continuously testing Flogo activities",
	"tags": [],
	"description": "",
	"content": " Depending on where you store the source code and how publicly you want to have the code available you have a few options to continuously testing Flogo activities. In this tutorial you\u0026rsquo;ll look at Jenkins when using a local git server and Travis-CI for activities on GitHub\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nJenkins \u0026amp; Travis-CI You\u0026rsquo;ll need to have Jenkins set up, together with the Go plugin (Go version 1.10 or higher) and you\u0026rsquo;ll need an account to Travis-CI. An account for the latter is free, if you want to use it with Open Source repositories.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Structure The project structure we\u0026rsquo;ll use has separate folders for activities and triggers. A sample layout would look like this:\n‚îú‚îÄ‚îÄ‚îÄ\u0026lt;Repo root\u0026gt; ‚îÇ ‚îî‚îÄ‚îÄ‚îÄactivity | | ‚îî‚îÄ‚îÄ‚îÄ\u0026lt;my-activity\u0026gt; | | |‚îÄ‚îÄ‚îÄ\u0026lt;all my files\u0026gt; ‚îÇ ‚îî‚îÄ‚îÄ‚îÄtrigger | ‚îî‚îÄ‚îÄ‚îÄ\u0026lt;my-trigger\u0026gt; | |‚îÄ‚îÄ‚îÄ\u0026lt;all my files\u0026gt;  For example, the Flogo Contrib repository looks like:\n‚îú‚îÄ‚îÄ‚îÄ flogo-contrib ‚îÇ ‚îî‚îÄ‚îÄ‚îÄa ctivity | ‚îî‚îÄ‚îÄ‚îÄ log | |‚îÄ‚îÄ‚îÄ README.md | |‚îÄ‚îÄ‚îÄ activity.go | |‚îÄ‚îÄ‚îÄ activity.json | |‚îÄ‚îÄ‚îÄ activity_test.go  Jenkins Installing the Go Plugin To get started with Go in Jenkins there is a great plugin that makes it all very easy. To install the Go Plugin for Jenkins go to Manage Jenkins -\u0026gt; Manage Plugins and search for Go Plugin on the Available tab. After that select Download now and install after restart to restart Jenkins.\nAfter you\u0026rsquo;ve done that, it is time to select the version of Go you want to use for the builds. Go to Manage Jenkins -\u0026gt; Global Tool Configuration and look for the Go section. Click on the button Go installations\u0026hellip; and specify a name for your installation. The name itself doesn\u0026rsquo;t have any significance, but it will make it a lot easier to find the right one later on. Check the box for Install automatically and select the version you want to have installed. After that click Apply follows by Save.\nConfiguring the build job Within Jenkins create a New Item and select a Freestyle project. Since repositories can have multiple activities, you can select a parameterized project.\nIn the Build Environment section you need to check two boxes:\n Delete workspace before build starts: This makes sure you always start with fresh code and nothing lingers around; Set up Go programming language tools: This was added by the Go Plugin and lets you pick the Go version you configured earlier (this is where the name comes in).  In the Build section add a new build step that executes a shell command. The shell command will take care of getting the dependencies and executing the test cases:\n## Go get the Project Flogo dependencies go get github.com/TIBCOSoftware/flogo-lib/... go get github.com/TIBCOSoftware/flogo-contrib/... ## Go get the test dependencies go get github.com/stretchr/testify/assert ## Find all the activities and run the test cases for them for path in ./activity/*; do [ -d \u0026quot;${path}\u0026quot; ] || continue # if not a directory, skip dirname=\u0026quot;$(basename \u0026quot;${path}\u0026quot;)\u0026quot; ## Run the test cases go test ./activity/$dirname done  Travis-CI For code that exists on GitHub there are a lot of options (including Jenkins), but let\u0026rsquo;s look at Travis-CI. Travis-CI is continuous integration for projects hosted on GitHub and provides automation for testing building and deploying. They have quite a good Getting Started guide, so this tutorial skips that part of the setup and dives right into it.\nAs you push your code to GitHub, the only additional file you need for Travis-CI to work is a file called .travis.yml (and you\u0026rsquo;ll need to turn on the builds from the Travis Web UI).\n## We don't need elevated privileges sudo: false ## The language should be Go and we'll use version 1.8.3 language: go go: - 1.10 ## The below statement skips all branches that start with a 'v' (e.g. v1) so that we can have working branches that get committed. branches: except: - /^v.*/ ## Install the dependencies we need install: - go get github.com/TIBCOSoftware/flogo-lib/... - go get github.com/TIBCOSoftware/flogo-contrib/... - go get github.com/stretchr/testify/assert ## The script is the same as it was in Jenkins, though joined to be a single line script: - for path in ./activity/*; do [ -d \u0026quot;${path}\u0026quot; ] || continue; dirname=\u0026quot;$(basename \u0026quot;${path}\u0026quot;)\u0026quot;; go test ./activity/$dirname; done; zip -r release.zip ./activity/ ./connector/  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/flogo-and-sam/",
	"title": "Flogo and SAM",
	"tags": [],
	"description": "",
	"content": " The AWS Serverless Application Model (AWS SAM) helps you to define serverless applications in simple and clean syntax. You can use the SAM CLI to manage Serverless applications written with AWS Serverless Application Model (SAM). SAM CLI can be used to test functions locally, start a local API Gateway from a SAM template, validate a SAM template, fetch logs, generate sample payloads for various event sources, and generate a SAM project in your favorite Lambda Runtime.\nIn this tutorial you\u0026rsquo;ll use the AWS SAM CLI to test a Flogo app that has a Lambda trigger, without deploying it to AWS Lambda. This will obviously increase the developer productivity even more!\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nAWS SAM CLI The demo makes use of the AWS SAM CLI. If you haven\u0026rsquo;t installed it yet, please check out the installation instructions for your OS.\nDocker The AWS SAM CLI makes use of Docker images to run your app locally. You need to have Docker installed and running on your machine to complete this tutorial.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: Building the app For this tutorial, you can make use of any app that uses the Lambda trigger. If you don\u0026rsquo;t have an app yet, you can use this one:\nThe Flogo app has a Lambda trigger and a PATH parameter called name.\n{ \u0026quot;name\u0026quot;: \u0026quot;Tutorial\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;start_flow_as_a_function_in_lambda\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/lambda\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Start Flow as a function in Lambda\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Lambda Trigger\u0026quot;, \u0026quot;settings\u0026quot;: {}, \u0026quot;handlers\u0026quot;: [ { \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:lambda_flow\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.evt.name\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;data\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.greeting\u0026quot; } ] } } } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:lambda_flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;LambdaFlow\u0026quot;, \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;any\u0026quot; } ] }, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Log Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;flowInfo\u0026quot;: \u0026quot;false\u0026quot;, \u0026quot;addToFlow\u0026quot;: \u0026quot;false\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;expression\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;string.concat(\\\u0026quot;Hello \\\u0026quot;, $flow.name)\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ] } } }, { \u0026quot;id\u0026quot;: \u0026quot;actreturn_3\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Return\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Return Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/actreturn\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;mappings\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;Hello\u0026quot;: \u0026quot;{{$flow.name}}\u0026quot;} } ] } } } ], \u0026quot;links\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;actreturn_3\u0026quot; } ] } } ] }  To create a Lambda file from this, you can run:\n// Create the app flogo create -f flogo.json myapp // Build the app cd myapp flogo build -e -shim start_flow_as_a_function_in_lambda  Step 2: Create a template.yml  You can use the sam local invoke command to manually test your code by running Lambda function locally. With SAM CLI, you can easily author automated integration tests by first running tests against local Lambda functions before deploying to the cloud.\n Now that is awesome! In order to make that work, SAM needs to have a descriptor called template.yml that describes what the function is and what other parameters it has. Assuming you\u0026rsquo;ve used the app above, a YAML file could look like\nAWSTemplateFormatVersion: '2010-09-09' Transform: 'AWS::Serverless-2016-10-31' Description: Serverless Application Model Resources: flogoapp: # The name you want to give your Lambda function Type: 'AWS::Serverless::Function' Properties: CodeUri: bin/ # The location where to find the executable file (not the zip file from the Web UI) Handler: handler # The name of the handler generated by the flogo build command Runtime: go1.x Tracing: Active Timeout: 120 Events: flogoevent: # This is a sample event Type: Schedule Properties: Schedule: cron(0 2 * * ? *) # Run at 2:00 am (UTC) every day Description: Run Hello World every night! # A description for your Lambda app MemorySize: 128 # The amount of memory you want to give your app in Lambda  For clarity sake, you can create a new directory called lambda and put all files in that directory.\nStep 3: Events To be able to test the apps locally, SAM makes use of events from JSON files. Events describe the input that would normally come from external apps like Amazon S3 or Amazon API Gateway. In this case, the event will be really simple. You\u0026rsquo;ll have to create a new file called event.json and the content of the file will be:\n{ \u0026quot;name\u0026quot;: \u0026quot;World\u0026quot; }  Step 4: Run locally Before you can run the app, the final step is to copy the executable file (generated in step 1) to the right location. Create a bin folder in the lambda folder you created earlier and copy the file /src/myapp/handler to that location.\nFrom a terminal window you can now use the SAM CLI to run your app locally:\nsam local invoke \u0026lt;function\u0026gt; -e \u0026lt;event.json file\u0026gt;  So in this case the command will be\nsam local invoke flogoapp -e event.json  As you run that, the output will look like (the last line will display the result of your app)\n2018-10-03 16:53:03 Invoking handler (go1.x) 2018-10-03 16:53:03 Found credentials in shared credentials file: ~/.aws/credentials Fetching lambci/lambda:go1.x Docker container image...... 2018-10-03 16:53:04 Mounting /Users/lstigter/Downloads/myapp/lambda/bin as /var/task:ro inside runtime container START RequestId: 8791ddd9-c612-1864-f381-75d1506ad692 Version: $LATEST 2018-10-03 23:53:05.119 INFO [trigger-flogo-lambda] - Starting AWS Lambda Trigger 2018/10/03 23:53:05 Starting AWS Lambda Trigger 2018/10/03 23:53:05 Received evt: 'map[name:World]' 2018/10/03 23:53:05 Received ctx: 'map[awsRequestId:8791ddd9-c612-1864-f381-75d1506ad692 functionName:test functionVersion:$LATEST logGroupName:/aws/lambda/test logStreamName:2018/10/03/[$LATEST]b1ff97369e34dbbe4f8ee4f578cde273 memoryLimitInMB:128]' 2018-10-03 23:53:05.123 INFO [activity-flogo-log] - Hello World END RequestId: 8791ddd9-c612-1864-f381-75d1506ad692 REPORT RequestId: 8791ddd9-c612-1864-f381-75d1506ad692\tDuration: 5.38 ms\tBilled Duration: 100 ms\tMemory Size: 128 MB\tMax Memory Used: 8 MB {\u0026quot;Hello\u0026quot;:\u0026quot;World\u0026quot;}  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/invoiceservice/",
	"title": "Invoice Service",
	"tags": [],
	"description": "",
	"content": " Let\u0026rsquo;s build an invoiceservice! In this tutorial we\u0026rsquo;ll walk you through building an app with several community-driven activities and talks to other services as well. The lab also covers Input/Output mappings, Invoking a REST service and Complex object mapping.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nApps This demo builds one of the services of the Kubernetes tutorial. After building this app, you might want to try and deploy it to Kubernetes too! The app will use the Payment Service to get some data, so you\u0026rsquo;ll likely want to start with that one if you haven\u0026rsquo;t built it yet.\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to get invoice information. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe invoice ID for which you want the information comes from the HTTP request. To get that parameter into the flow, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;id\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. You can create them by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. From there, select Output and configure two parameters:\n Parameter name: code Type: integer  Now click on the + sign to add a new parameter\n Parameter name: response Type: any  Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n Port: The port on which your app will listen (set this to 9234) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /api/invoices/:id, the :id means that you can use that as a path parameter in your mappings)  After that, click on \u0026ldquo;Map to flow inputs\u0026rdquo; to map the invoiceId from the HTTP trigger to the \u0026ldquo;id\u0026rdquo; parameter we created earlier. The parameter will already be selected because it is the only one. Since the data will come from the PATH parameters, you\u0026rsquo;ll need to type $.pathParams.id in the input box, which means the Flogo app will expect a PATH parameter called invoiceId to be present.\nWith the inputs taken care off, let\u0026rsquo;s look at the outputs. Click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;response\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well‚Ä¶, saved. You can click the little X on the top-right (no, not your browser‚Ä¶) to close the dialog window and go back to the flow.\nThe URL on which our microservice will listen will be http://localhost:9234/api/invoices/:id (the :invoiceId is a parameter that you can replace with anything during runtime). If you made changes to any of the variables above, please make sure to change those in the rest of these examples.\n Step 3: Add activities You‚Äôll have to add some acvitivities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type string.concat(\u0026quot;Get Invoice request received for: \u0026quot;, $flow.id) in the box (on the right hand side of the screen). This will, when you run the app, concatenate a string and the id.\nIn the same way, add a new activity. The activity that is needed, to generate a random number, isn\u0026rsquo;t part of the out-of-the-box activities so you\u0026rsquo;ll need to import it.\nClick \u0026ldquo;Install new activity\u0026rdquo; and a dialog appears where you can paste (or type) the URL of where the Flogo Web UI can get the sources. For this activity you can use https://github.com/retgits/flogo-components/activity/randomnumber. From the updated list you can pick the \u0026ldquo;Random number\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Random number\u0026rdquo; activity.\n max: 2000 (the maximum value the random number will have) min: 1000 (the minimum value the random number will have)  In the same way, add a new activity and this time install the \u0026ldquo;Combine\u0026rdquo; activity to concatenate multiple values. The URL you\u0026rsquo;ll need to use to install the activity is https://github.com/jvanderl/flogo-components/activity/combine.\n delimeter: \u0026quot;-\u0026quot; (the delimeter used to separate the strings) part1: \u0026quot;INV\u0026quot; (a hardcoded string) part2: $flow.id (the id that was passed in as a PATH parameter)  Add another \u0026ldquo;Random number\u0026rdquo; activity to the flow, in the same way you\u0026rsquo;ve done before. This time you won\u0026rsquo;t need to install it, because the Flogo Web UI already knows about it. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Random number\u0026rdquo; activity.\n max: 1000 (the maximum value the random number will have) min: 0 (the minimum value the random number will have)  The next step is to add a \u0026ldquo;Invoke REST Service\u0026rdquo; activity, which will call the Payment Service to get some data. You can add the activity in the same way you\u0026rsquo;ve done before. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs:\n content: \u0026lt;empty\u0026gt; (the content you want to send to the REST service, in this case the service doesn\u0026rsquo;t need any so you can keep this field empty) header: \u0026lt;empty\u0026gt; (any header parameters you want to send to the REST service, in this case the service doesn\u0026rsquo;t need any so you can keep this field empty) method: \u0026quot;GET\u0026quot; (the HTTP method to call the other service) pathParams: {\u0026quot;id\u0026quot;:\u0026quot;{{$flow.id}}\u0026quot;} (this will add a PATH parameter with the value of the id that was passed into this flow) proxy: \u0026lt;empty\u0026gt; (HTTP proxy settings you need to call the other service you can keep this field empty) queryParams: \u0026lt;empty\u0026gt; (any query parameters you want to send to the REST service, in this case the service doesn\u0026rsquo;t need any so you can keep this field empty) skipSsl: \u0026quot;false\u0026quot; (This setting indicates if, when HTTPS is used, the certificate check should be skipped or not) uri: http://localhost:9233/api/expected-date/:id (This is the URL, including any PATH parameters used, to call the other service. In this case the Payment Service)  Step 4: Return data To complete the flow, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200.\nNow click on \u0026ldquo;* message\u0026rdquo; and type (or copy) the structure below. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\n{ \u0026quot;id\u0026quot;:\u0026quot;{{$flow.id}}\u0026quot;, \u0026quot;ref\u0026quot;:\u0026quot;{{$activity[combine_4].result}}\u0026quot;, \u0026quot;amount\u0026quot;:\u0026quot;{{$activity[randomnumber_3].result}}\u0026quot;, \u0026quot;balance\u0026quot;:\u0026quot;{{$activity[randomnumber_5].result}}\u0026quot;, \u0026quot;expectedPaymentDate\u0026quot;:\u0026quot;{{$activity[rest_6].result.expectedDate}}\u0026quot;, \u0026quot;currency\u0026quot;:\u0026quot;USD\u0026quot; }  The above snippet maps the values from the REST service to fields that are sent back to the trigger. The mapping is done in a JavaScript-like syntax, so $flow.id means it will get the id that was used as an input parameter to the flow (the one you configured earlier) and the $activity[xxx].result will get the result elements from the various activities. The double curly braces are used as by Go\u0026rsquo;s templating engine.\nYour final flow should look something like the one below.\nStep 5: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026ldquo;\u0026lt;\u0026rdquo; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo;. Choose whichever operating system you\u0026rsquo;re running on to download the executable.\nStep 6: Run To see the results, start both apps and run curl --request GET --url http://localhost:9234/api/invoices/12345. That will give you a result like\n{\u0026quot;amount\u0026quot;:1456,\u0026quot;balance\u0026quot;:456,\u0026quot;currency\u0026quot;:\u0026quot;USD\u0026quot;,\u0026quot;expectedPaymentDate\u0026quot;:\u0026quot;2018-02-28\u0026quot;,\u0026quot;id\u0026quot;:\u0026quot;2345\u0026quot;,\u0026quot;ref\u0026quot;:\u0026quot;INV-2345\u0026quot;}  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/iot-howto/",
	"title": "IoT Apps",
	"tags": [],
	"description": "",
	"content": " Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you. The app you\u0026rsquo;ll build has a REST trigger that counts the number of times it is invoked and logs that to the console.\n{ \u0026quot;name\u0026quot;: \u0026quot;IoTApp\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple REST Trigger\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: 9233 }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:counter_flow\u0026quot; } }, \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/counter\u0026quot; } } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:counter_flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;CounterFlow\u0026quot;, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;counter_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Increment Counter\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Global Counter Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/counter\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;counterName\u0026quot;: \u0026quot;number\u0026quot;, \u0026quot;increment\u0026quot;: true, \u0026quot;reset\u0026quot;: false } } }, { \u0026quot;id\u0026quot;: \u0026quot;log_3\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Log Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;flowInfo\u0026quot;: \u0026quot;false\u0026quot;, \u0026quot;addToFlow\u0026quot;: \u0026quot;false\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$activity[counter_2].value\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ] } } } ], \u0026quot;links\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;counter_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;log_3\u0026quot; } ] } } ] }  Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the Flogo CLI to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nThe next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nStep 3: Running the app You have just built the Flogo app, so now you can test it. From the bin directory (cd bin) you can run ./myapp which will start the app. In the terminal you\u0026rsquo;ll see something like\n2018-05-12 04:34:56.434 INFO [engine] - Engine Starting... 2018-05-12 04:34:56.435 INFO [engine] - Starting Services... 2018-05-12 04:34:56.435 INFO [engine] - Started Services 2018-05-12 04:34:56.435 INFO [engine] - Starting Triggers... 2018-05-12 04:34:56.435 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-05-12 04:34:56.435 INFO [engine] - Triggers Started 2018-05-12 04:34:56.435 INFO [engine] - Engine Started  To test it we\u0026rsquo;ll use the curl command line tool, which is installed on most Operating Systems. From a new terminal window execute the command curl http://localhost:9233/counter. It will send an HTTP request to the app on port 9233 (which was configured in the flogo.json file) and it will log the number of invocations.\nStep 4: Getting it to your device Once you are ready to test your application on your device, check out these specialized labs that talk about building Flogo apps specifically for that device.\n Raspberry Pi Intel Edison BeagleBone  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/beaglebone-iot/",
	"title": "IoT Apps: BeagleBone",
	"tags": [],
	"description": "",
	"content": " Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI. Let\u0026rsquo;s look at building for BeagleBone!\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nIoT How-to This demo makes use of the IoT Apps tutorial. If you haven\u0026rsquo;t done that one yet, this is a great time to do so!\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Building an app To build a Flogo application for BeagleBone, you simply use the build command with the appropriate enviroment variables set to compile to Go code for an ARM processor.\nOn macOS or Linux machines the additional parameters you need to set when building Flogo apps are:\nenv GOARM=7 GOARCH=arm GOOS=linux flogo build -e  On Windows the additional parameters you need to set when building Flogo apps are:\nSET GOARM=7 SET GOARCH=arm SET GOOS=linux flogo build -e  Note that the above samples compile for an ARMv6 processor. You can check the BeagleBone website to see which version of the ARM processor you have.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/edison-iot/",
	"title": "IoT Apps: Intel Edison",
	"tags": [],
	"description": "",
	"content": " Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI. Let\u0026rsquo;s look at building for Intel Edison!\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nIoT How-to This demo makes use of the IoT Apps tutorial. If you haven\u0026rsquo;t done that one yet, this is a great time to do so!\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Building an app To build a Flogo application for BeagleBone, you simply use the build command with the appropriate enviroment variables set to compile to Go code for an 386 architecture processor.\nOn macOS or Linux machines the additional parameters you need to set when building Flogo apps are:\nenv GOARCH=386 GOOS=linux flogo build -e  On Windows the additional parameters you need to set when building Flogo apps are:\nSET GOARCH=386 SET GOOS=linux flogo build -e  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/raspberry-iot-cli/",
	"title": "IoT Apps: Raspberry Pi",
	"tags": [],
	"description": "",
	"content": " Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI. Let\u0026rsquo;s look at building for Raspberry Pi!\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nIoT How-to This demo makes use of the IoT Apps tutorial. If you haven\u0026rsquo;t done that one yet, this is a great time to do so!\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Building an app To build a Flogo application for Raspberry Pi, you simply use the build command with the appropriate enviroment variables set to compile to Go code for an ARM processor.\nOn macOS or Linux machines the additional parameters you need to set when building Flogo apps are:\nenv GOARM=6 GOARCH=arm GOOS=linux flogo build -e  On Windows the additional parameters you need to set when building Flogo apps are:\nSET GOARM=6 SET GOARCH=arm SET GOOS=linux flogo build -e  Note that the above samples compile for an ARMv6 processor. You can check the Raspberry Pi website to see which version of the ARM processor you have.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "",
	"content": " Kubernetes is probably the most wellknown container orchestration platform out there, with a ton of companies building and hosting their own specific version or making use of of one. In this demo you explore how to run Flogo apps on Kubernetes. The demo will walk you through deploying two apps:\n An invoice service which gets details on the invoice you specify in the URL A payment service which gets details on the expected payment date for the invoice (The invoice service will make use of the payment service to display all data)  What you\u0026rsquo;ll need The demo needs a working Kubernetes cluster. If you haven\u0026rsquo;t got one, setting one up using minikube is quite easy! You\u0026rsquo;ll also need to have the Flogo CLI installed. If that is not the case, you might want to install them first. Our Getting Started guide walks you through the installation of Go, the Flogo CLI and Go Dep.\nScripts A fully scripted version of this tutorial is available in the samples directory as well! There are two different scenarios to deploy, one makes use of apps built using the Flogo Web UI and the other makes use of apps with the same functionality but built using the Go API.\nThe apps built with the Flogo Web UI are:\n Invoice Service Payment Service  The apps built with the Go API are:\n Invoice Service - Go Payment Service - Go  The shell script will allow you to choose between them, in this walk through you\u0026rsquo;ll make use of the apps built with the Flogo Web UI. In the scenario you\u0026rsquo;ll find a bunch of code blocks from which you can copy the code directly to your terminal. Please note that these commands are for MacOS and Linux, but should work on most Windows based systems as well.\nGetting the artifacts The first step is to create a directory that will contain all the artifacts. For now we\u0026rsquo;ll call that one flogo-on-kubernetes\n# Set a root directory so that all commands start from the same directory ROOTDIR=`pwd` # Set a working directory for all the artifacts WORKDIR=flogo-on-kubernetes # Make sure the directory is cleanly created rm -rf $ROOTDIR/$WORKDIR mkdir -p $ROOTDIR/$WORKDIR  Getting the Flogo apps The demo will consist of two apps deployed to a Kubernetes cluster. We\u0026rsquo;ll use docker images that already exist, but we do want to provide you with all the code and artifacts to show the apps in the Flogo Web UI. Let\u0026rsquo;s start with downloading the apps\ncd $ROOTDIR/$WORKDIR curl -o invoiceservice.json https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/invoiceservice.json curl -o paymentservice.json https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/paymentservice.json  For each of the apps we\u0026rsquo;ll need to run a command to create the app structure and download any dependencies\nflogo create -f invoiceservice.json invoiceservice flogo create -f paymentservice.json paymentservice  Creating executables Now, let\u0026rsquo;s build the executables for the first app. We\u0026rsquo;ll build two executables. One that will be able to run natively on your machine and one that will be a Linux executable to run in a docker container. So for the first app those commands are\ncd $ROOTDIR/$WORKDIR/invoiceservice env GOOS=linux flogo build -e flogo build -e  For the second app they are\ncd $ROOTDIR/$WORKDIR/paymentservice env GOOS=linux flogo build -e flogo build -e  Dockerize all the things Now on to Docker! We\u0026rsquo;ll create docker images based on Alpine Linux. We\u0026rsquo;ll put a Dockerfile in the bin/linux_amd64 folder and run the command\n# Set your Docker Hub username DOCKERHUBUSER=my-name # Go to the right directory cd $ROOTDIR/$WORKDIR/invoiceservice/bin/linux_amd64 # Get a Dockerfile curl -o Dockerfile https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/Dockerfile # Run the docker build command docker build -t $DOCKERHUBUSER/invoiceservice .  And we\u0026rsquo;ll do the same for the second service as well.\n# Go to the right directory cd $ROOTDIR/$WORKDIR/paymentservice/bin/linux_amd64 # Get a Dockerfile curl -o Dockerfile https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/Dockerfile # Run the docker build command docker build -t $DOCKERHUBUSER/paymentservice .  Running your Docker images Right now you have two new docker images available in your registry, which you could use to test the whole scenario as well. If you want to do that run the below commands in separate terminal windows\ndocker run --rm -it -p 9998:8080 $DOCKERHUBUSER/paymentservice docker run --rm -it -p 9999:8080 -e PAYMENTSERVICE=http://\u0026lt;YOUR IP\u0026gt;:9998/api/expected-date/:id $DOCKERHUBUSER/invoiceservice\u0026quot;  Now you can test the flow by running\n# For the payment service curl --request GET --url http://localhost:9998/api/expected-date/1234 # For the invoice service curl --request GET --url http://localhost:9999/api/invoices/1234  For more information and sample messages check out the prebuilt docker images for these services on Docker Hub\n invoiceservice paymentservice  Speaking of Docker Hub\u0026hellip; you can push your docker containers to Docker Hub (assuming you have an account for it) by running\ndocker push $DOCKERHUBUSER/paymentservice:latest docker push $DOCKERHUBUSER/invoiceservice:latest  On to Kubernetes The last step is to deploy to Kubernetes. To do that we need to download two additional files.\ncd $ROOTDIR/$WORKDIR curl -o invoice-svc.yml https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/invoice-svc.yml curl -o payment-svc.yml https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/payment-svc.yml  The payment-svc.yml file will create a deployment and a service resource in your Kubernetes cluster. For that we\u0026rsquo;ll use an existing docker image called retgits/paymentservice, which is the same as the one you just built. If you want you can update the yaml file before running the below command.\nkubectl apply -f payment-svc.yml  You now have a docker container that is accessible as a service on Kubernetes. The payment service is accessible on port 80 of the cluster IP address that was assigned to it. If you want to try it out look for the CLUSTER-IP of the payment-svc in the output from kubectl get services\nkubectl run curl --image=radial/busyboxplus:curl -i --tty  This will start a new buxybox terminal in your cluster. From there you can run\ncurl \u0026lt;CLUSTERIP\u0026gt;/api/expected-date/3456  which should return something like \u0026quot;{\u0026quot;expectedDate\u0026quot;:\u0026quot;2018-02-26\u0026quot;,\u0026quot;id\u0026quot;:\u0026quot;3456\u0026quot;}\nThe second service we\u0026rsquo;ll make available using the type: LoadBalancer which means that you can access it from outside your Kubernetes cluster. For this we\u0026rsquo;ll use the existing container retgits/invoiceservice. If you open the invoice.yml file you\u0026rsquo;ll see that there is an environment variable called PAYMENTSERVICE (line 24) which points to the DNS entry for the payment service. This way we can makes updates and potentially move the payment service around without having to update this service.\nkubectl apply -f invoice-svc.yml  Done All done! You now have two Flogo apps running on a Kubernetes cluster which you invoke by sending a curl message to the Kubernetes IP address or localhost if you\u0026rsquo;re running Docker for Mac. You can execute a command like:\ncurl localhost:80/api/invoices/1234  which will return something like \u0026quot;{\u0026quot;amount\u0026quot;:1162,\u0026quot;balance\u0026quot;:718,\u0026quot;currency\u0026quot;:\u0026quot;USD\u0026quot;,\u0026quot;expectedPaymentDate\u0026quot;:\u0026quot;2018-03-02\u0026quot;,\u0026quot;id\u0026quot;:\u0026quot;1234\u0026quot;,\u0026quot;ref\u0026quot;:\u0026quot;INV-1234\u0026quot;}\u0026quot;\nHappy Kube-ing!!\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/helloworld/",
	"title": "My First App: Hello World",
	"tags": [],
	"description": "",
	"content": " Like with every programming language, a \u0026ldquo;Hello World\u0026rdquo; project gets you started with some basic fundamentals and Project Flogo really isn\u0026rsquo;t that different. This lab will get you started with the Flogo Web UI and building a simple flow.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. To make it easy to get started the Flogo Web UI is packaged up as a docker image which you can get from [docker hub](docker hub. To install Docker for your operating system click here for macOS and here for Windows. The Flogo Web UI contains everything you\u0026rsquo;ll need to build your Flogo apps, without ever writing code.\nIf you\u0026rsquo;re planning to run on a Windows machine older than Windows 10, you\u0026rsquo;ll need to install Docker Toolbox\n Step 1: Starting the Flogo Web UI To get started with the latest version of the Flogo Web UI paste this command in a terminal window:\ndocker run -it -p 3303:3303 flogo/flogo-docker:latest eula-accept  The parameters after the docker run command are:\n -it: This parameter keeps a pseudo-tty terminal open and keeps the terminal running in interactive mode. The Flogo Web Ui will print logs to this terminal window -p 3303:3303: This parameter tells Docker to bind your computer\u0026rsquo;s port 3303 to the container\u0026rsquo;s port 3303 flogo/flogo-docker:latest: This parameter tells the Docker daemon which container you want to run. In this case it will try to get the latest version of flogo/flogo-docker eula-accept: This parameter says you\u0026rsquo;ve accepted the EULA agreement on our website  After it is done starting the container, you\u0026rsquo;ll see something like the image below in your terminal.\nTo see the Flogo Web UI, open your favorite web browser, and navigate to http://localhost:3303. You\u0026rsquo;ll see our mascot Flynn there to greet you!\nStep 2: Create the app In Flogo terminology, an app is comprised of one or more triggers and flows (actions). The app itself is really just an organizational mechanism that can be leveraged when developing microservices \u0026amp; functions. An app contains a set of configurations, as well as triggers and a collection of flows.\nTo create a new app, open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 3: Add a flow In Flogo, a flow is an implementation of an action and is the primary tool to implement business logic. A flow can consist of a number of different constructs:\n Activties: One or more activities that implement specific logic (for example write to a database, invoke a REST endpoint, etc) Links: Each activity is connected via a link (Links can contain conditional logic to alter the path of a flow)  Flows, as previously stated in the triggers section, can exist without a trigger. Thus, flows operate very similar to functions, that is, a single flow can define its own input \u0026amp; output parameters. Thus, enabling a flow to be reused regardless of the trigger entrypoint To create a new flow you can click either the + New Flow button at the top or the Create a flow button in the middle of the screen.\nNo matter which you pick, you\u0026rsquo;ll be presented with a dialog to give your new flow a name and an optional description. Click Create to create the new flow and click on the newly created flow to open the editor.\nStep 4: Add a trigger Flogo is an event-driven framework. A trigger is the entrypoint for events to, as the name implies, trigger the functionality of your app. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions (flows).\nTo add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe thing you want to log comes from the HTTP request. To get that parameter into the flow, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;name\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. From the screen where you are now, select Output and configure two parameters:\n Parameter name: code Type: integer  Now click on the + sign to add a new parameter\n Parameter name: message Type: any  Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n Port: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /test/:name, the :name means that you can use that as a path parameter in your mappings).  The URL on which our microservice will listen will be http://localhost:9233/test/:name (the :name is a parameter that you can replace with anything during runtime). If you made changes to any of the variables above, please make sure to change those in the rest of these examples.\n Step 5: Adding activities An activity is the unit of work that can be leveraged within a Flow. An activity can be any number of things and can be compared to a simple function in Go or any other procedural language, that is, an activity accepts input params and will return one or more objects on return, both input \u0026amp; output params are defined by the activity metadata. You‚Äôll have to add some acvitivities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type (or copy/paste) string.concat(\u0026quot;Hello \u0026quot;, $flow.name) in the box (on the right hand side of the screen).\nStep 6: Return data To complete the app, add a Return activity. To add an activity click on the large + sign.\nHover over the newly added activity to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200. Now click on \u0026ldquo;a.. message\u0026rdquo; and type string.concat(\u0026quot;Hello \u0026quot;, $flow.name) in the input field. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nStep 7: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. Click on build and select your operating system of choice! Flogo will compile a statically linked binary, meaning that there are no other dependencies that the executable you\u0026rsquo;re getting from the Flogo Web UI. No libraries to install, no frameworks to maintain or upgrade, just that one single binary that takes care of your flows.\nProject Flogo can build binaries for most platforms that exist. If you choose to build one for a unix based system (e.g. Linux or macOS) be sure to add the executable property to it (chmod +x \u0026lt;executable\u0026gt;).\n Step 8: Run your app To run the app double-click it (on Windows), or open a terminal and execute the downloaded binary. As you\u0026rsquo;ll do that, you\u0026rsquo;ll not only see the output of the log step, but you\u0026rsquo;ll see the same in your browser window as well. The URL on which our microservice will listen should be http://localhost:9233/test/:name (or might be different if you made changes in the previous steps). If you\u0026rsquo;re running it on your machine you can open a browser window and go to http://localhost:9233/test/flogo to see what the output was (spoiler alert: you\u0026rsquo;ll see \u0026quot;Hello flogo\u0026quot; in your web browser). To stop your app simply close the terminal window in which you started the app or press ctrl + c\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/timers/",
	"title": "My First App: Timers",
	"tags": [],
	"description": "",
	"content": " Timers are great to schedule stuff, and a great way to learn new technology! Use this lab to get familiar with some of the concepts of Flogo!\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. To make it easy to get started the Flogo Web UI is packaged up as a docker image which you can get from docker hub. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI. The Flogo Web UI contains everything you\u0026rsquo;ll need to build your Flogo apps, without ever writing code.\nStep 1: Create the app In Flogo terminology, an app is comprised of one or more triggers and flows (actions). The app itself is really just an organizational mechanism that can be leveraged when developing microservices \u0026amp; functions. An app contains a set of configurations, as well as triggers and a collection of flows.\nTo create a new app, open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Flogo is an event-driven framework. A trigger is the entrypoint for events to, as the name implies, trigger the functionality of your app. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions (flows).\nIn this case you want to start with a Timer. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Timer trigger.\nNow it is time to configure the trigger. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n repeating: This tells the trigger wheter it should stop after executing once, or repeat itself after a certain interval (set this to true) notImmediate: This tells the trigger to wait until tehe first interval is done or start right away (set this to false) startDate: You can specify what the start date is for the trigger to become active, for example if you want to deploy the app and want it to start in a few hours (keep this at 2018-01-01T12:00:00Z00:00) hours: This will tell the trigger how many hours to wait between runs (keep this field empty) minutes: This will tell the trigger how many minutes to wait between runs (keep this field empty) seconds: This will tell the trigger how many seconds to wait between runs (set this to 5, to start a new flow every 5 seconds)  Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well‚Ä¶, saved. You can click the little X on the top-right (no, not your browser‚Ä¶) to close the dialog window and go back to the flow.\nStep 3: Add activities An activity is the unit of work that can be leveraged within a Flow. An activity can be any number of things and can be compared to a simple function in Go or any other procedural language, that is, an activity accepts input params and will return one or more objects on return, both input \u0026amp; output params are defined by the activity metadata. You‚Äôll have to add some acvitivities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type Hello World in the box (on the right hand side of the screen).\nWith all the updates, your flow should look something like the one below.\nStep 4: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. Click on build and select your operating system of choice! Flogo will compile a statically linked binary, meaning that there are no other dependencies that the executable you\u0026rsquo;re getting from the Flogo Web UI. No libraries to install, no frameworks to maintain or upgrade, just that one single binary that takes care of your flows.\nStep 5: Run To run the app double-click it (on Windows), or open a terminal and execute:\n2018-09-26 14:03:31.917 INFO [engine] - Engine Starting... 2018-09-26 14:03:31.917 INFO [engine] - Starting Services... 2018-09-26 14:03:31.917 INFO [engine] - Started Services 2018-09-26 14:03:31.917 INFO [engine] - Starting Triggers... 2018-09-26 14:03:31.917 INFO [trigger-flogo-timer] - Scheduling a repeating job 2018-09-26 14:03:31.917 INFO [engine] - Trigger [ timer ]: Started 2018-09-26 14:03:31.917 INFO [engine] - Triggers Started 2018-09-26 14:03:31.917 INFO [engine] - Engine Started 2018-09-26 14:03:31.917 INFO [engine] - Running FlowAction for URI: 'res://flow:timers' 2018-09-26 14:03:31.918 INFO [activity-flogo-log] - Hello World... 2018-09-26 14:03:31.918 INFO [engine] - Flow instance [db4cb555d16b2c2189f1a2b217379b66] Completed Successfully 2018-09-26 14:03:36.919 INFO [engine] - Running FlowAction for URI: 'res://flow:timers' 2018-09-26 14:03:36.919 INFO [activity-flogo-log] - Hello World... 2018-09-26 14:03:36.919 INFO [engine] - Flow instance [d84cb555d16b2c2189f1a2b217379b66] Completed Successfully  Every 5 seconds a new entry will appear in the log.\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/paymentservice/",
	"title": "Payment Service",
	"tags": [],
	"description": "",
	"content": " The payment service is a service that uses a few communiy-driven activities to build out a Flogo microservice to generate a date when payment is expected. The lab also covers Input/Output mappings and Complex object mapping.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nKubernetes demo This demo builds one of the services of the Kubernetes tutorial. After building this app, you might want to try and deploy it to Kubernetes too!\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to generate the date. To add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe invoice ID for which you need to generate a date comes from the HTTP request. To get that parameter into the flow, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;invoiceid\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. You can create them by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. From there, select Output and configure two parameters:\n Parameter name: code Type: integer  Now click on the + sign to add a new parameter\n Parameter name: response Type: any  Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n Port: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /api/expected-date/:invoiceId, the :invoiceId means that you can use that as a path parameter in your mappings)  After that, click on \u0026ldquo;Map to flow inputs\u0026rdquo; to map the invoiceId from the HTTP trigger to the \u0026ldquo;invoiceid\u0026rdquo; parameter we created earlier. The parameter will already be selected because it is the only one. Since the data will come from the PATH parameters, you\u0026rsquo;ll need to type $.pathParams.invoiceId in the input box, which means the Flogo app will expect a PATH parameter called invoiceId to be present.\nWith the inputs taken care off, let\u0026rsquo;s look at the outputs. Click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;response\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well‚Ä¶, saved. You can click the little X on the top-right (no, not your browser‚Ä¶) to close the dialog window and go back to the flow.\nThe URL on which our microservice will listen will be http://localhost:9233/api/expected-date/:invoiceId (the :invoiceId is a parameter that you can replace with anything during runtime). If you made changes to any of the variables above, please make sure to change those in the rest of these examples.\n Step 3: Add activities You‚Äôll have to add some acvitivities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. The activity that is needed, to generate a random number, isn\u0026rsquo;t part of the out-of-the-box activities so you\u0026rsquo;ll need to import it. Click \u0026ldquo;Install new activity\u0026rdquo; and a dialog appears where you can paste (or type) the URL of where the Flogo Web UI can get the sources. For this activity you can use https://github.com/retgits/flogo-components/activity/randomnumber. From the updated list you can pick the \u0026ldquo;Random number\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Random number\u0026rdquo; activity.\n max: 10 (the maximum value the random number will have) min: 0 (the minimum value the random number will have)  In the same way, add a new activity and this time install the \u0026ldquo;Add to date\u0026rdquo; activity to add a number of days to the current date. The URL you\u0026rsquo;ll need to use to install the activity is https://github.com/retgits/flogo-components/activity/addtodate.\nFrom the updated list you can pick the \u0026ldquo;Add to date\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Add to date\u0026rdquo; activity.\n date: \u0026quot;\u0026quot; (leave this blank, which means using the current date) units: \u0026quot;days\u0026quot; (this means you\u0026rsquo;ll add days. Other possible values are \u0026quot;years\u0026quot; and \u0026quot;months\u0026quot;)  For the number you\u0026rsquo;ll need to perform a mapping. Select the activity input \u0026ldquo;number\u0026rdquo; and click on the grey carret next to the Random Number activity in the \u0026ldquo;Available Data\u0026rdquo; list. This will display a list of all the outputs from that activity and you\u0026rsquo;ll need to click on \u0026ldquo;result\u0026rdquo; to populate the input box with the value of that field. As your app is running, it will mean the output of that activity will be passed in as the input for this one.\nStep 4: Return data To complete the flow, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200.\nNow click on \u0026ldquo;* message\u0026rdquo; and type (or copy) the structure below. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\n{\u0026quot;id\u0026quot;:\u0026quot;{{$flow.invoiceid}}\u0026quot;,\u0026quot;expectedDate\u0026quot;:\u0026quot;{{$activity[addtodate_3].result}}\u0026quot;}  The above snippet maps the values from the REST service to fields that are sent back to the trigger. The mapping is done in a JavaScript-like syntax, so $flow.invoiceid means it will get the invoiceId that was used as an input parameter to the flow (the one you configured earlier) and the $activity[addtodate_3].result will get the result from the \u0026ldquo;Add to date\u0026rdquo; activity. The double curly braces are used as by Go\u0026rsquo;s templating engine.\nYour final flow should look something like the one below.\nStep 5: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026ldquo;\u0026lt;\u0026rdquo; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo;. Choose whichever operating system you\u0026rsquo;re running on to download the executable.\nStep 6: Run To see the results, start your app and run curl --request GET --url http://localhost:9233/api/expected-date/12345. That will give you a result like\n{\u0026quot;expectedDate\u0026quot;:\u0026quot;2018-10-01\u0026quot;,\u0026quot;id\u0026quot;:12345}  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/pubnub/",
	"title": "PubNub",
	"tags": [],
	"description": "",
	"content": " Building microservices is awesome, having them talk to each other is even more awesome! But in today\u0026rsquo;s world, you can\u0026rsquo;t be too careful when it comes to sending sensitive data across the wire. In this demo you explore how to build a simple microservice to receive the messages from PubNub and write that data to a file.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nA PubNub account In order to work with PubNub, you\u0026rsquo;ll really need a PubNub account. Luckily, registration is very easy. Go to https://dashboard.pubnub.com/login and use \u0026ldquo;SIGN UP\u0026rdquo; to create a new account.\nStep 1: Create an app in PubNub After signing up, use the big red button to create a new app (the name doesn\u0026rsquo;t matter, and if you want you can change it later too). Now click on the newly created app and you\u0026rsquo;ll see a new KeySet. The Publish and Subscriber key are quite important as they make sure you can connect to your PubNub account.\nStep 2: Create an an in the Flogo Web UI Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 3: Import a new trigger Out of the box, Flogo doesn\u0026rsquo;t come with a trigger for PubNub so using the awesome SDK provided by the PubNub team we\u0026rsquo;ve built one for you! To install that into your Web UI, click on the + icon on the left hand side of the screen.\nFrom there click on \u0026ldquo;Install new\u0026rdquo; and paste \u0026ldquo;https://github.com/retgits/flogo-components/trigger/pubnubsubscriber\u0026rdquo; into the input dialog to get this new trigger. After the installation is completed, you can click on \u0026ldquo;Receive PubNub messages\u0026rdquo; to add the trigger to your app.\nStep 4: Configuration The thing we want to store in a file is the message coming from PubNub. To do so, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;pubnubmessage\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nNow it is time to configure the trigger to listen to messages coming from PubNub. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n publishKey: The key from PubNub (usually starts with pub-c) subscribeKey: The key from PubNub (usually starts with sub-c) channel: The channel on which messages will come (totally up to you to choose this)  After that, click on \u0026ldquo;Map to flow inputs\u0026rdquo; to map the message from PubNub to the \u0026ldquo;pubnubmessage\u0026rdquo; parameter we created earlier. The parameter will already be selected because it is the only one, so the only task left is to click \u0026ldquo;* message\u0026rdquo; in the Trigger Output section and \u0026ldquo;save\u0026rdquo; to make sure everything is, well‚Ä¶, saved. You can click the little X on the top-right (no, not your browser‚Ä¶) to close the dialog window and go back to the flow.\nStep 5: Adding activities You‚Äôll have to add some acvitivities to the flow for it to do something. In this demo you\u0026rsquo;ll add two activities to the flow. The first activity will log the message and the second one will store the data in a file. To add an activity click on the other large + sign\nOn the right-hand side of the screen a list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity using data from all other activities and triggers in your flow. Right now, we have only the incoming data from PubNub so select \u0026ldquo;message\u0026rdquo; in the \u0026ldquo;Activity Inputs\u0026rdquo; section and expand the \u0026ldquo;flow (flow)\u0026rdquo; section (by clicking on the little black caret) to be able to select the \u0026ldquo;pubnubmessage\u0026rdquo;.\nNow hit the \u0026ldquo;save\u0026rdquo; button and we\u0026rsquo;re done with this part!\nNow we need to add a new activity to the Flogo Web UI to make sure you can add things to a file. Add a new activity, like you did before, and click \u0026ldquo;Install new activity\u0026rdquo; to get the same dialog as when installing the trigger.\nIn the dialog window you can paste \u0026ldquo;https://github.com/retgits/flogo-components/activity/writetofile\u0026rdquo;. Once the activity is installed you can select it from the list to add it to your flow. Again, hover over the newly added activity and expand the menu to configure your activity. For this activity you\u0026rsquo;ll have to configure all the parameters:\n Append: Should the content be appended to the file or not? In this case we want to, so type \u0026ldquo;true\u0026rdquo; in the box Content: The content we want to add to the file. In this case it is the message from PubNub again, so expand the \u0026ldquo;flow (flow)\u0026rdquo; section (by clicking on the little black caret) and select the \u0026ldquo;pubnubmessage\u0026rdquo; Create: Should the file be created if it doesn\u0026rsquo;t exist? Well, yes, in this case that is probably a good idea so type \u0026ldquo;true\u0026rdquo; in the box Filename: The name of the file you want to write the data to. In this case you can call the file whatever you want, like \u0026ldquo;visitors.txt\u0026rdquo; (please be sure to add the double quotes as you type in the box)  Click \u0026ldquo;save\u0026rdquo; to save the data and return to the main screen of your flow. The completed flow will look like\nStep 6: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo; and choose your operating system of choice. That will tell the Flogo Web UI to go build your microservice and give you a tiny executable in return (about 12mb).\nStep 7: Test You can run your microservice by either double-clicking it (on Windows) or using a terminal window to run your app (macOS or Linux). If the app started successfully it will give you a message like: 2018-08-06 21:20:02.867 INFO [engine] - Received status [pubnub.PNConnectedCategory], this is expected for a subscribe, this means there is no error or issue whatsoever\nTo test the microservice you can use the PubNub debug console.\nIn the \u0026ldquo;Default Channel\u0026rdquo; you\u0026rsquo;ll have to type the same channel name as you configured in your Flogo app (MyChannel, in this example). You can click \u0026ldquo;ADD CLIENT\u0026rdquo; to create a new client which will be able to send and receive data. The cool thing that PubNub offers, is that you don\u0026rsquo;t have to open any firewall ports to have the debug console and the microservice talk to each other. At the bottom of the page it will now say {\u0026quot;text\u0026quot;:\u0026quot;Enter Message Here\u0026quot;}, which is the message that you can send to your microservice. Either hit \u0026ldquo;SEND\u0026rdquo; or perhaps replace the default message with something like {\u0026quot;Hello\u0026quot;:\u0026quot;World\u0026quot;}. After you click \u0026ldquo;SEND\u0026rdquo; the exact message will appear in the window where your microservice is running\nAnd in the log file that was created in the same location as your app\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/raspberry-iot/",
	"title": "Raspberry Pi",
	"tags": [],
	"description": "",
	"content": " A Raspberry Pi is probably one of the most well-known small single-board computers built to promote the teaching of basic computer science, and increasingly used for cool IoT projects. Flogo runs perfectly on these small devices, and in this lab you\u0026rsquo;ll build a sample to read and write data to the GPIO pins of the device\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo Web UI\nDevices You\u0026rsquo;ll definitely want to have a Raspberry Pi, to run the app!\nStep 1: Create the app Open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 2: Add a trigger Triggers are used to signal a flow to run. In this case you want to receive an HTTP message to turn on or off the lights. To add a trigger, click on the + icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. You can create them by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. From there, select Output and configure two parameters:\n Parameter name: code Type: integer  Now click on the + sign to add a new parameter\n Parameter name: message Type: string  Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n Port: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (this can be anything, like /light/status)  After that, click on \u0026ldquo;Map to flow outputs\u0026rdquo; to map the output parameters you created earlier to the response of the trigger. The code parameter will already be selected, so click on \u0026ldquo;123 code\u0026rdquo; in the Flow Output section to create the mapping. Now click on \u0026ldquo;message\u0026rdquo; in the Trigger Response section and select \u0026ldquo;* data\u0026rdquo; from the Flow Output section to create the mapping. Click \u0026ldquo;save\u0026rdquo; to make sure everything is, well‚Ä¶, saved. You can click the little X on the top-right (no, not your browser‚Ä¶) to close the dialog window and go back to the flow.\nStep 3: Add activities You‚Äôll have to add some acvitivities to the flow for it to do something. To add an activity click on the other large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type Received request. in the box (on the right hand side of the screen).\nIn the same way you just added the Log activity, now add a Control GPIO activity and configure it in the same way with:\n method: Direction pinNumber: 23 direction: Output  This will tell the app you\u0026rsquo;ll want to use pin number 23.\nAdd another Control GPIO activity and configure it in the same way with:\n method: Read State pinNumber: 23  This will tell the app you want to know the output state of pin number 23.\nYour flow should look something like the one below.\nStep 4: Adding a branch To be able to switch from on to off and vice versa, you\u0026rsquo;ll need to create two branches. One that turns off the light if it was on and one that does the opposite. You\u0026rsquo;ll start by creating the \u0026ldquo;Turn it on\u0026rdquo; branch.\nAs you hover over the activity, a cog will appear and as you hover over that thing, a menu will appear to create a branch from your activity.\nClick anywhere on the branch to be able to set a condition. The condition is a JavaScript-like syntax $activity[gpio_4].result==0. You can create the condition by simply typing it into the textbox. Where it says gpio_4 in the condition, you might need to change that to match the ID of the activity you added last (it will have the name \u0026ldquo;Control GPIO(2)\u0026rdquo;).\nAdd a new Log Message activity (click on the + right behind the created branch) and as you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In the modal that now appears, select \u0026ldquo;a.. message\u0026rdquo; to tell the app what the message is that will be logged. Now click on the caret next to the second GPIO activity to expand it and click \u0026ldquo;123 result\u0026rdquo; to tell the app to map the result from that activity to the message that will be logged.\nAdd another Control GPIO activity (yes, a lot of GPIO activities are used in this flow\u0026hellip;) and configure it in the same way you did with the previous activities, but with the values:\n method: Set State pinNumber: 23 state: high  To complete the branch, add a Return activity. Hover over it to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200.\nNow click on \u0026ldquo;a.. message\u0026rdquo; and type \u0026ldquo;Updated light to high successfully\u0026rdquo; (the quotes are needed). Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nWith all the updates, your flow should look something like the one below.\nStep 5: Adding another branch To create the second branch, the \u0026ldquo;Turn it off\u0026rdquo; branch, select the activity from which you created the first branch. Create a branch in the same way, by hovering over the activity first. As you hover over the activity, a cog will appear and as you hover over that thing, a menu will appear to create a branch from your activity.\nClick anywhere on the branch to be able to set a condition. This time, set the condition to $activity[gpio_4].result==1. Where it says gpio_4 in the condition, you might need to change that to match the ID of the activity you added last (it will have the name \u0026ldquo;Control GPIO(2)\u0026rdquo;).\nAdd a new Log Message activity (click on the + right behind the newly created branch) and as you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In the modal that now appears, select \u0026ldquo;a.. message\u0026rdquo; to tell the app what the message is that will be logged. Now click on the caret next to the second GPIO activity to expand it and click \u0026ldquo;123 result\u0026rdquo; to tell the app to map the result from that activity to the message that will be logged.\nAdd a Control GPIO activity (we promise, this is the last GPIO activity\u0026hellip;) and configure it in the same way you did with the previous activities, but with the values:\n method: Set State pinNumber: 23 state: low  This branch should be completed with a Return activity as well. Hover over it to see the cog and select configure to bring up the modal to configure the activity. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200 and this time set the field \u0026ldquo;a.. message\u0026rdquo; to \u0026ldquo;Updated light to low successfully\u0026rdquo; (the quotes are needed). Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nWith all the updates, your final flow should look something like the one below.\nStep 6: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. That will bring you back to your microservice and from here you can select \u0026ldquo;Build\u0026rdquo; and choose linux/arm to make sure it is capable of running on a Raspberry Pi.\nStep 7: Run To run your app copy it to your Raspberry Pi and run curl --request GET --url http://localhost:9233/lights/status (or replace localhost with the IP address of your device)\n"
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/serverless/",
	"title": "Serverless Framework",
	"tags": [],
	"description": "",
	"content": " Building serverless apps is awesome! As a developer you don\u0026rsquo;t have to worry about provisioning or maintaining servers, and you only have to create the code that you need to power your next business idea! Deploying such apps is made super easy by the team at Serverless Framework.With the Serverless Framework, you can configure which events should trigger it, where to deploy it and what kind of resources it is allowed to use without going into the AWS console.\nWhat you\u0026rsquo;ll need Serverless Framework You\u0026rsquo;ll need to have the Serverless Framework installed. If you haven\u0026rsquo;t done that yet, now would be a great time to do so!\nAWS account To finally deploy your apps you\u0026rsquo;ll need an AWS account. If you haven\u0026rsquo;t signed up yet, this would be a great time to do that too.\nStep 1: Using the template The first step is to create a sample project based on the Flogo template.\nserverless create -u https://github.com/tibcosoftware/flogo/tree/master/serverless -p myservice  That command just generated a bunch of files for you\nmyservice \u0026lt;-- A new directory with the name of your service ‚îú‚îÄ‚îÄ hello \u0026lt;-- A folder with the sources of your function ‚îÇ ‚îú‚îÄ‚îÄ function.go \u0026lt;-- A Hello World function ‚îÇ ‚îî‚îÄ‚îÄ main.go \u0026lt;-- The Lambda trigger code, created by Flogo ‚îú‚îÄ‚îÄ .gitignore \u0026lt;-- A .gitignore file to ignore the things you don't want in git ‚îú‚îÄ‚îÄ Makefile \u0026lt;-- A Makefile to build and deploy even faster ‚îú‚îÄ‚îÄ README.md \u0026lt;-- A quickstart guide ‚îî‚îÄ‚îÄ serverless.yaml \u0026lt;-- The Serverless Framework template  The content of main.go comes directly from the Lambda trigger. The function.go file has three methods that make up the entire app\n init: The init method makes sure that everything is ready to go. It sets the default loglevels, creates an app by calling shimApp() and ultimately starts the engine shimApp: shimApp is used to build a new Flogo app and register the Lambda trigger with the engine. The shimapp is used by the shim, which triggers the engine every time an event comes into Lambda. It registers the method that it should call each time and in this case that method is RunActivities RunActivities: RunActivities is where the magic happens. This is where you get the input from any event that might trigger your Lambda function in a map called evt (which is part of the inputs). The sample will simply log \u0026ldquo;Go Serverless v1.x! Your function executed successfully!\u0026rdquo; and return the same as a response. The trigger, in main.go, will take care of marshalling it into a proper response for the API Gateway  Step 2: Build and Deploy To build the executable that you want to deploy to Lambda, you can run make or make build. That command, in turn, executes two other commands:\n go generate ./...: In order to run the activities and triggers that you have uses, the Flogo engine needs to have all the metadata available. This command generates the metadata so that it can be compiled into the executable env GOOS=linux go build -ldflags=\u0026quot;-s -w\u0026quot; -o bin/hello hello/*.go: This command creates the executable (which should run on Linux) from the sources in the hello folder and stores the result (a file called hello) in the bin folder.  To deploy the app run make deploy or, if you don\u0026rsquo;t want to use make, run sls deploy --verbose to get the same result. This command will deploy your function to AWS Lambda.\nThe output on your screen will have something like what is pasted below:\n\u0026lt;snip\u0026gt; Service Information service: myservice stage: dev region: us-east-1 stack: myservice-dev api keys: None endpoints: GET - https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello functions: hello: myservice-dev-hello \u0026lt;snip\u0026gt;  Step 3: Test it Using cURL you can test your new function\ncurl --request GET --url https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello --header 'content-type: application/json'  The above command will call your function and return a result:\n{\u0026quot;message\u0026quot;: \u0026quot;Go Serverless v1.x! Your function executed successfully!\u0026quot;}  Step 4: Adding a POST operation That was pretty easy, and pretty cool, but not really useful. The next step is all about updating the code to not only handle GET, but also POST operations and provide a more personalized response.\nThe first thing is to update the serverless.yml file with a new event handler. Around line 58 of the file you\u0026rsquo;ll find the events and the types of events that can trigger your app. It already has an entry for GET, copy and paste that and change the method to POST.\nfunctions: hello: handler: bin/hello events: - http: path: hello method: get - http: path: hello method: post  Step 5: Build the code The second part is to update the RunActivities method. In this step you\u0026rsquo;ll walk through the entire method.\nIn order to distinguish the two HTTP methods, you\u0026rsquo;ll have to look at the httpMethod element of the incoming message:\n// Get the HTTP method from the event method := inputs[\u0026quot;evt\u0026quot;].Value().(map[string]interface{})[\u0026quot;httpMethod\u0026quot;].(string) // Create a variable for the message var message string // Decide which way to take switch method { case \u0026quot;GET\u0026quot;: case \u0026quot;POST\u0026quot;: }  Creating the response, so after the switch statement is completed, will still be the same:\n// Using a Flogo activity to log the message in := map[string]interface{}{\u0026quot;message\u0026quot;: message} _, err := flogo.EvalActivity(\u0026amp;log.LogActivity{}, in) if err != nil { return nil, err } // The response from the Lambda function is always in the form of a JSON message. // In this case we're creating a structure with a single element called // message responseData := make(map[string]interface{}) responseData[\u0026quot;message\u0026quot;] = message // Because we're sending the result back to the API Gateway, it will expect to have // both an HTTP result code (called code) and some response data. In this case we're // sending back the data object we created earlier response := make(map[string]*data.Attribute) response[\u0026quot;code\u0026quot;], _ = data.NewAttribute(\u0026quot;code\u0026quot;, data.TypeInteger, 200) response[\u0026quot;data\u0026quot;], _ = data.NewAttribute(\u0026quot;data\u0026quot;, data.TypeAny, responseData) return response, nil  In case of a GET operation, the message should still be the same. You can update the GET part by pasting in message = \u0026quot;Go Serverless v1.x! Your function executed successfully!\u0026quot;\nIn case of a POST operation, the message will be a little different. In that case you want to reply with the name of the person that called your function.\n// API Gateway passes in the body as a string, so the first step // is to parse the body to a JON object, or map[string]interface{} in Go var eventBody map[string]interface{} if err := json.Unmarshal([]byte(inputs[\u0026quot;evt\u0026quot;].Value().(map[string]interface{})[\u0026quot;body\u0026quot;].(string)), \u0026amp;eventBody); err != nil { return nil, err } // The message you want to log message = fmt.Sprintf(\u0026quot;%v is going all in on Serverless v1.x!\u0026quot;, eventBody[\u0026quot;name\u0026quot;])  Putting everything together, the new method will look like\n// Get the HTTP method from the event method := inputs[\u0026quot;evt\u0026quot;].Value().(map[string]interface{})[\u0026quot;httpMethod\u0026quot;].(string) // Create a variable for the message var message string // Decide which way to take switch method { case \u0026quot;GET\u0026quot;: message = \u0026quot;Go Serverless v1.x! Your function executed successfully!\u0026quot; case \u0026quot;POST\u0026quot;: // API Gateway passes in the body as a string, so the first step // is to parse the body to a JON object, or map[string]interface{} in Go var eventBody map[string]interface{} if err := json.Unmarshal([]byte(inputs[\u0026quot;evt\u0026quot;].Value().(map[string]interface{})[\u0026quot;body\u0026quot;].(string)), \u0026amp;eventBody); err != nil { return nil, err } // The message you want to log message = fmt.Sprintf(\u0026quot;%v is going all in on Serverless v1.x!\u0026quot;, eventBody[\u0026quot;name\u0026quot;]) } // Using a Flogo activity to log the message in := map[string]interface{}{\u0026quot;message\u0026quot;: message} _, err := flogo.EvalActivity(\u0026amp;log.LogActivity{}, in) if err != nil { return nil, err } // The response from the Lambda function is always in the form of a JSON message. // In this case we're creating a structure with a single element called // message responseData := make(map[string]interface{}) responseData[\u0026quot;message\u0026quot;] = message // Because we're sending the result back to the API Gateway, it will expect to have // both an HTTP result code (called code) and some response data. In this case we're // sending back the data object we created earlier response := make(map[string]*data.Attribute) response[\u0026quot;code\u0026quot;], _ = data.NewAttribute(\u0026quot;code\u0026quot;, data.TypeInteger, 200) response[\u0026quot;data\u0026quot;], _ = data.NewAttribute(\u0026quot;data\u0026quot;, data.TypeAny, responseData) return response, nil  Step 6: Build and Deploy To build and deploy the updates you can use one command: make deploy. This command will build the new executable and deploy your function to AWS Lambda.\nThe output on your screen will have something like what is pasted below:\n\u0026lt;snip\u0026gt; Service Information service: myservice stage: dev region: us-east-1 stack: myservice-dev api keys: None endpoints: GET - https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello POST - https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello functions: hello: myservice-dev-hello \u0026lt;snip\u0026gt;  Step 7: Test it\u0026hellip; again Using cURL you can test that your function still works for a GET operation. The command\ncurl --request GET --url https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello --header 'content-type: application/json'  Should still respond with:\n{\u0026quot;message\u0026quot;: \u0026quot;Go Serverless v1.x! Your function executed successfully!\u0026quot;}  When you POST a message, though\ncurl --request POST --url https://xxx.execute-api.us-east-1.amazonaws.com/dev/hello --header 'content-type: application/json' --data '{\u0026quot;name\u0026quot;: \u0026quot;Flogo\u0026quot;}'  The result should be different\n{\u0026quot;message\u0026quot;: \u0026quot;Flogo is going all in on Serverless v1.x!\u0026quot;}  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/streams-aggregate/",
	"title": "Streams: Aggregate",
	"tags": [],
	"description": "",
	"content": " Project Flogo is an ultra-light, Go-based open source ecosystem for building event-driven apps. It provides a bunch of capabilities to build those apps, like:\n Integration Flows: Application Integration process engine with conditional branching and a visual development environment Stream Processing: a simple pipeline-based stream processing action with event joining capabilities across multiple triggers \u0026amp; aggregation over time windows Contextual Decisioning: Declarative Rules for Real-time Contextual Decisions  In this tutorial you will learn how to use the Stream Processing capability in Flogo\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: Prepare the app The first step to create a Flogo streams app is to create a quick, barebones Flogo app using the Flogo CLI. Using the Flogo CLI, you\u0026rsquo;ll need to specify that it should get the master branch of both flogo-lib to make sure you can build a streaming app correctly. The command to execute is\nflogo create -flv \u0026lt;branch you need\u0026gt; \u0026lt;appname\u0026gt;  So in your case, using the name aggregator, the command will be\nflogo create -flv github.com/TIBCOSoftware/flogo-contrib/activity/log@master,github.com/TIBCOSoftware/flogo-lib/app/resource@master aggregator  Step 2: Create the JSON file Open up the flogo.json file that was created in the aggregator directory and delete all the contents. For this tutorial, you\u0026rsquo;ll be guided through the different sections of the flogo.json and what they mean:\n Trigger Action Resources Stages  General stuff Before you can get to define the app, you\u0026rsquo;ll need to define some metadata that the app model needs as well. The fields name, type, version, and appModel describe the metadata of the app and the JSON model you\u0026rsquo;re building through this tutorial. For this tutorial, that part of the file will look like:\n{ \u0026quot;name\u0026quot;: \u0026quot;aggregator\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, }  Trigger Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions. In this case, the trigger will be the REST trigger that comes out-of-the-box with Flogo. The trigger has a bunch of configurations that are important:\n It will listen on port 9234 It will have a GET method registered for the endpoint /aggregate/:val As messages come in, it will call an action with id simple_agg The input to that action is a parameter called input and is assigned the value of the PATH parameter val  Since there could be multiple triggers, the triggers element is an array. In this tutorial, though, you\u0026rsquo;ll only use one REST trigger\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: \u0026quot;9234\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/aggregate/:val\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;simple_agg\u0026quot;, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;input\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.pathParams.val\u0026quot; } ] } } } ] } ] }  Action An action is a generic implementation for processing the incoming event. Different types of actions can be implemented, thus defining different methods by which an incoming event can be processed. In your case, a pipeline is needed (which is implemented by the github.com/project-flogo/stream action) and it will dispatch the event to the resource with the URI res://pipeline:simple_agg\n{ \u0026quot;actions\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;simple_agg\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/stream\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;pipelineURI\u0026quot;: \u0026quot;res://pipeline:simple_agg\u0026quot; } } ] }  Resources The resources are the actual workhorses of the Flogo app. They define, among a ton of other things, the sequences in which activities have to be executed, rules that need to be followed and parameters that need to be mapped. First, let\u0026rsquo;s look at the metadata of the resource that defines the input and the output. In this case the input is an integer called input and the output is an integer called result.\n{ \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;pipeline:simple_agg\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;input\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;result\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot; } ] }, }  Stages The stages, as the name implies, define the sequential steps that a pipeline needs to perform. The first step is the aggregator activity, which:\n Sums all the inputs Using a time tumbling window of 5000 milliseconds (5 seconds) The input to the activity is simply a straight-through mapping of the input parameter  The second activity is a log activity, where the message field is mapped straight from the result field of the aggregator activity. Note that in stream actions, unlike flow actions, only the output of the preceding activity is available and not all other outputs.\n{ \u0026quot;stages\u0026quot;: [ { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/aggregate\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;function\u0026quot;: \u0026quot;sum\u0026quot;, \u0026quot;windowType\u0026quot;: \u0026quot;timeTumbling\u0026quot;, \u0026quot;windowSize\u0026quot;: \u0026quot;5000\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;=$.input\u0026quot; } }, { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;=$.result\u0026quot; } } ] }  The completed flow The complete flogo.json will look like\n{ \u0026quot;name\u0026quot;: \u0026quot;aggregator\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: \u0026quot;9234\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/aggregate/:val\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;simple_agg\u0026quot;, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;input\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.pathParams.val\u0026quot; } ] } } } ] } ], \u0026quot;actions\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;simple_agg\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/stream\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;pipelineURI\u0026quot;: \u0026quot;res://pipeline:simple_agg\u0026quot; } } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;pipeline:simple_agg\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;input\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;result\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot; } ] }, \u0026quot;stages\u0026quot;: [ { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/aggregate\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;function\u0026quot;: \u0026quot;sum\u0026quot;, \u0026quot;windowType\u0026quot;: \u0026quot;timeTumbling\u0026quot;, \u0026quot;windowSize\u0026quot;: \u0026quot;5000\u0026quot; }, \u0026quot;input\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;=$.input\u0026quot; } }, { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;=$.result\u0026quot; } } ] } } ] }  Step 3: Install dependencies In your app, you\u0026rsquo;re making use of a few external dependencies that you need to install into your app for the Go compiler to be able to successfully build the app. To install external dependencies, you need to run\nflogo install \u0026lt;dependency location\u0026gt;  So in the case of this tutorial, you\u0026rsquo;ll need to run\nflogo install github.com/project-flogo/stream flogo install github.com/TIBCOSoftware/flogo-lib/app/resource flogo install github.com/TIBCOSoftware/flogo-contrib/activity/aggregate  Step 4: Build the app The next step is to build the executable. To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nflogo build -e  Step 5: Run To run the app you just built, open a terminal and run\ncd bin ./aggregator  You can send commands to it using cURL\ncurl --request GET --url http://localhost:9234/aggregate/1  If you send a number of requests within the 5000 millisecond window, the Flogo app will aggregate them and provide the sum of the numbers:\n2018-10-04 07:47:31.444 INFO [engine] - Engine Starting... 2018-10-04 07:47:31.444 INFO [engine] - Starting Services... 2018-10-04 07:47:31.444 INFO [engine] - Started Services 2018-10-04 07:47:31.444 INFO [engine] - Starting Triggers... 2018-10-04 07:47:31.445 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-10-04 07:47:31.445 INFO [engine] - Triggers Started 2018-10-04 07:47:31.445 INFO [engine] - Engine Started 2018-10-04 07:48:41.514 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-10-04 07:48:42.224 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-10-04 07:48:42.784 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-10-04 07:48:43.351 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-10-04 07:48:46.515 INFO [activity-flogo-log] - 4  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/labs/streams-filter/",
	"title": "Streams: Counter",
	"tags": [],
	"description": "",
	"content": " Project Flogo is an ultra-light, Go-based open source ecosystem for building event-driven apps. It provides a bunch of capabilities to build those apps, like:\n Integration Flows: Application Integration process engine with conditional branching and a visual development environment Stream Processing: a simple pipeline-based stream processing action with event joining capabilities across multiple triggers \u0026amp; aggregation over time windows Contextual Decisioning: Declarative Rules for Real-time Contextual Decisions  In this tutorial you will learn how to use the Stream Processing capability in Flogo\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: Prepare the app The first step to create a Flogo streams app is to create a quick, barebones Flogo app using the Flogo CLI. Using the Flogo CLI, you\u0026rsquo;ll need to specify that it should get the master branch of both flogo-lib to make sure you can build a streaming app correctly. The command to execute is\nflogo create -flv \u0026lt;branch you need\u0026gt; \u0026lt;appname\u0026gt;  So in your case, using the name streamfilter, the command will be\nflogo create -flv github.com/TIBCOSoftware/flogo-contrib/activity/log@master,github.com/TIBCOSoftware/flogo-lib/app/resource@master streamfilter  Step 2: Create the JSON file Open up the flogo.json file that was created in the streamfilter directory and delete all the contents. For this tutorial, you\u0026rsquo;ll be guided through the different sections of the flogo.json and what they mean:\n Trigger Action Resources Stages  General stuff Before you can get to define the app, you\u0026rsquo;ll need to define some metadata that the app model needs as well. The fields name, type, version, and appModel describe the metadata of the app and the JSON model you\u0026rsquo;re building through this tutorial. For this tutorial, that part of the file will look like:\n{ \u0026quot;name\u0026quot;: \u0026quot;aggregator\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, }  Trigger Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions. In this case, the trigger will be the REST trigger that comes out-of-the-box with Flogo. The trigger has a bunch of configurations that are important:\n It will listen on port 9234 It will have a GET method registered for the endpoint /filter/:val As messages come in, it will call an action with id simple_agg The input to that action is a parameter called input and is assigned the value of the PATH parameter val  Since there could be multiple triggers, the triggers element is an array. In this tutorial, though, you\u0026rsquo;ll only use one REST trigger\n{ \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: \u0026quot;9234\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/filter/:val\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;simple_agg\u0026quot;, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;input\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.pathParams.val\u0026quot; } ] } } } ] } ], }  Action An action is a generic implementation for processing the incoming event. Different types of actions can be implemented, thus defining different methods by which an incoming event can be processed. In your case, a pipeline is needed (which is implemented by the github.com/project-flogo/stream action) and it will dispatch the event to the resource with the URI res://pipeline:simple_filter\n{ \u0026quot;actions\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;simple_agg\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/stream\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;pipelineURI\u0026quot;: \u0026quot;res://pipeline:simple_filter\u0026quot; } } ] }  Resources The resources are the actual workhorses of the Flogo app. They define, among a ton of other things, the sequences in which activities have to be executed, rules that need to be followed and parameters that need to be mapped. First, let\u0026rsquo;s look at the metadata of the resource that defines the input and the output. In this case the input is an integer called input (and no output).\n{ \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;pipeline:simple_agg\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;input\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot; } ] }, }  Stages The stages, as the name implies, define the sequential steps that a pipeline needs to perform. The first step is the filter activity, which:\n Filters all inputs using the non-zero filter The input to the activity is simply a straight-through mapping of the input parameter  The second activity is a log activity, where the message field is mapped straight from the value field of the filter activity. Note that in stream actions, unlike flow actions, only the output of the preceding activity is available and not all other outputs.\n{ \u0026quot;stages\u0026quot;: [ { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/filter\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;non-zero\u0026quot;, \u0026quot;proceedOnlyOnEmit\u0026quot;: true }, \u0026quot;input\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;=$.input\u0026quot; } }, { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;=$.value\u0026quot; } } ] }  The completed flow The complete flogo.json will look like\n{ \u0026quot;name\u0026quot;: \u0026quot;streamfilter\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: \u0026quot;9234\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/filter/:val\u0026quot; }, \u0026quot;action\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;simple_agg\u0026quot;, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;input\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.pathParams.val\u0026quot; } ] } } } ] } ], \u0026quot;actions\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;simple_agg\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/project-flogo/stream\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;pipelineURI\u0026quot;: \u0026quot;res://pipeline:simple_filter\u0026quot; } } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;pipeline:simple_filter\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;input\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot; } ] }, \u0026quot;stages\u0026quot;: [ { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/filter\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;non-zero\u0026quot;, \u0026quot;proceedOnlyOnEmit\u0026quot;: true }, \u0026quot;input\u0026quot;: { \u0026quot;value\u0026quot;: \u0026quot;=$.input\u0026quot; } }, { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;=$.value\u0026quot; } } ] } } ] }  Step 3: Install dependencies In your app, you\u0026rsquo;re making use of a few external dependencies that you need to install into your app for the Go compiler to be able to successfully build the app. To install external dependencies, you need to run\nflogo install \u0026lt;dependency location\u0026gt;  So in the case of this tutorial, you\u0026rsquo;ll need to run\nflogo install github.com/project-flogo/stream flogo install github.com/TIBCOSoftware/flogo-lib/app/resource flogo install github.com/TIBCOSoftware/flogo-contrib/activity/filter  Step 4: Build the app The next step is to build the executable. To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nflogo build -e  Step 5: Run To run the app you just built, open a terminal and run\ncd bin ./streamfilter  You can send commands to it using cURL and sending values that are non-zero should result in a log message. Events with a value of 0, will not result in a log message.\ncurl --request GET --url http://localhost:9234/filter/1 curl --request GET --url http://localhost:9234/filter/0 curl --request GET --url http://localhost:9234/filter/1  The above requests will result in the log activity being executed only twice\n2018-10-04 08:16:46.048 INFO [engine] - Engine Starting... 2018-10-04 08:16:46.049 INFO [engine] - Starting Services... 2018-10-04 08:16:46.049 INFO [engine] - Started Services 2018-10-04 08:16:46.049 INFO [engine] - Starting Triggers... 2018-10-04 08:16:46.050 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-10-04 08:16:46.050 INFO [engine] - Triggers Started 2018-10-04 08:16:46.050 INFO [engine] - Engine Started 2018-10-04 08:16:51.514 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-10-04 08:16:51.515 INFO [activity-flogo-log] - 1 2018-10-04 08:16:51.530 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-10-04 08:16:51.545 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-10-04 08:16:51.545 INFO [activity-flogo-log] - 1  "
},
{
	"uri": "https://tibcosoftware.github.io/flogo/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]